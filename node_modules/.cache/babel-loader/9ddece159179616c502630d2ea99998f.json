{"ast":null,"code":"import React from 'react';\nimport { find_next_cell, is_valid } from './lib';\nimport '../sudoku_global';\n/******************* Testing function ********************/\n// test = [[8,5,0,0,0,2,4,0,0],\n// [7,2,0,0,0,0,0,0,9],\n// [0,0,4,0,0,0,0,0,0],\n// [0,0,0,1,0,7,0,0,2],\n// [3,0,5,0,0,0,9,0,0],\n// [0,4,0,0,0,0,0,0,0],\n// [0,0,0,0,8,0,0,7,0],\n// [0,1,7,0,0,0,0,0,0],\n// [0,0,0,0,3,6,0,4,0]]\n// global.backtrack_count = 0\n// global.values = []\n// val = backtrack_smart(test, 0, 0)\n// for (let i = 0; i < 9; i++) {\n//     console.log(test[i].toString())\n// }\n// console.log(global.values)\n// console.log(global.backtrack_count, val)\n// imply(test, 0, 0, 1)\n\n/******************* Methods ********************/\n\nexport default function backtrack_smart(grid) {\n  // function backtrack_smart(grid) {\n  let i, j, ret, implied_values;\n  ret = find_next_cell(grid); // console.log('DEBUG')\n  // for (let i = 0; i < 9; i++) {\n  //     console.log(grid[i].toString())\n  // }\n  // console.log(\"next cell is \", ret)\n\n  i = ret[0];\n  j = ret[1];\n\n  if (i == -1) {\n    return true;\n  }\n\n  for (let e = 1; e < 10; e++) {\n    if (is_valid(grid, i, j, e)) {\n      grid[i][j] = e;\n      implied_values = imply(grid, i, j, e);\n      global.values.push([i, j, e]);\n      global.values = [...global.values, ...implied_values]; // global.values = [...global.values, ...implied_values]\n\n      if (backtrack_smart(grid, i, j)) {\n        return true;\n      } // undoing the implied values\n\n\n      grid[i][j] = 0;\n\n      for (let x = 0; x < implied_values.length; x++) {\n        grid[implied_values[x][0]][implied_values[x][1]] = 0;\n        global.values.push([implied_values[x][0], implied_values[x][1], 0]);\n      }\n\n      global.values.push([i, j, 0]);\n      global.backtrack_count++;\n    }\n  }\n\n  return false;\n} // separate into 9 regions\n// can also take the sum of each set and subtract from current so that if current has only 1 value, then that means it must be that value\n// (row_start, row_end, col_start, col_end)\n\nfunction imply(grid, i, j, e) {\n  let sectors = [[0, 3, 0, 3], [3, 6, 0, 3], [6, 9, 0, 3], [0, 3, 3, 6], [3, 6, 3, 6], [6, 9, 3, 6], [0, 3, 6, 9], [3, 6, 6, 9], [6, 9, 6, 9]];\n  let implied_values = [];\n  grid[i][j] = e;\n  let complete_set, v;\n  let all_values = new Set([...Array(10).keys()]);\n  all_values.delete(0);\n  let flag = 1;\n\n  while (flag == 1) {\n    flag = 0;\n    let possible_values = [...Array(9)].map(i => Array(9).fill(0));\n\n    for (let sec = 0; sec < sectors.length; sec++) {\n      for (let i = sectors[sec][0]; i < sectors[sec][1]; i++) {\n        for (let j = sectors[sec][2]; j < sectors[sec][3]; j++) {\n          if (grid[i][j] == 0) {\n            complete_set = new Set(); // adding values for rows and columns\n\n            for (let x = 0; x < 9; x++) {\n              // add the values it CAN NOT be             \n              if (grid[i][x] != 0) {\n                complete_set.add(grid[i][x]);\n              }\n\n              if (grid[x][j] != 0) {\n                complete_set.add(grid[x][j]);\n              }\n            } // adding the values for the respective box\n            // add the values it CAN NOT be             \n\n\n            for (let x = sectors[sec][0]; x < sectors[sec][1]; x++) {\n              for (let y = sectors[sec][2]; y < sectors[sec][3]; y++) {\n                if (grid[x][y] != 0) {\n                  complete_set.add(grid[x][y]);\n                }\n              }\n            }\n\n            possible_values[i][j] = [...complete_set]; // possible_values[i][j] contains values it cannot be\n            // possible_values[i][j] contains values it can be\n\n            possible_values[i][j] = new Set([...all_values].filter(x => !possible_values[i][j].includes(x)));\n\n            if (possible_values[i][j].size == 1) {\n              v = possible_values[i][j].values().next().value;\n\n              if (is_valid(grid, i, j, v)) {\n                // console.log(\"found one\", v)\n                implied_values.push([i, j, v]);\n                grid[i][j] = v;\n                flag = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return implied_values; // return {\"iv\": implied_values, \"g\": grid}\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/sudoku_setup/sudoku_algorithms/backtrack_smart.js"],"names":["React","find_next_cell","is_valid","backtrack_smart","grid","i","j","ret","implied_values","e","imply","global","values","push","x","length","backtrack_count","sectors","complete_set","v","all_values","Set","Array","keys","delete","flag","possible_values","map","fill","sec","add","y","filter","includes","size","next","value"],"mappings":"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","sourcesContent":["import React from 'react'\nimport {find_next_cell, is_valid} from './lib'\nimport '../sudoku_global'\n\n/******************* Testing function ********************/\n// test = [[8,5,0,0,0,2,4,0,0],\n// [7,2,0,0,0,0,0,0,9],\n// [0,0,4,0,0,0,0,0,0],\n// [0,0,0,1,0,7,0,0,2],\n// [3,0,5,0,0,0,9,0,0],\n// [0,4,0,0,0,0,0,0,0],\n// [0,0,0,0,8,0,0,7,0],\n// [0,1,7,0,0,0,0,0,0],\n// [0,0,0,0,3,6,0,4,0]]\n\n// global.backtrack_count = 0\n// global.values = []\n\n// val = backtrack_smart(test, 0, 0)\n// for (let i = 0; i < 9; i++) {\n//     console.log(test[i].toString())\n// }\n// console.log(global.values)\n// console.log(global.backtrack_count, val)\n\n\n// imply(test, 0, 0, 1)\n/******************* Methods ********************/\n\nexport default function backtrack_smart(grid) {\n    // function backtrack_smart(grid) {\n    let i , j, ret, implied_values\n    ret = find_next_cell(grid)\n    // console.log('DEBUG')\n    // for (let i = 0; i < 9; i++) {\n    //     console.log(grid[i].toString())\n    // }\n    // console.log(\"next cell is \", ret)\n    i = ret[0]\n    j = ret[1]\n    if (i == -1) {\n        return true\n    }\n    for (let e= 1; e < 10; e++) {\n        if (is_valid(grid, i, j, e) ) {\n            grid[i][j] = e\n            implied_values = imply(grid, i, j, e)\n            global.values.push([i,j,e])\n            global.values = [...global.values,...implied_values]\n            // global.values = [...global.values, ...implied_values]\n            if (backtrack_smart(grid, i, j)) {\n                return true\n            }\n            // undoing the implied values\n            grid[i][j] = 0\n            for (let x = 0; x < implied_values.length; x++) {\n                grid[implied_values[x][0]][implied_values[x][1]] = 0\n                global.values.push([implied_values[x][0], implied_values[x][1], 0])\n            }\n            global.values.push([i,j,0])\n            global.backtrack_count ++;\n        }\n    }\n    return false\n}   \n\n// separate into 9 regions\n// can also take the sum of each set and subtract from current so that if current has only 1 value, then that means it must be that value\n// (row_start, row_end, col_start, col_end)\nfunction imply(grid, i, j, e) {\n    let sectors= [[0,3,0,3],[3,6,0,3],[6,9,0,3],[0,3,3,6],[3,6,3,6],[6,9,3,6],[0,3,6,9],[3,6,6,9],[6,9,6,9]]\n    let implied_values = []\n    grid[i][j] = e\n    let complete_set, v\n    let all_values = new Set([...Array(10).keys()])\n    all_values.delete(0)\n    let flag = 1\n    while (flag == 1) {\n        flag = 0\n        let possible_values = [...Array(9)].map(i=>Array(9).fill(0))\n        for (let sec = 0; sec < sectors.length; sec++) {\n            for (let i = sectors[sec][0]; i < sectors[sec][1]; i++) {\n                for (let j = sectors[sec][2]; j < sectors[sec][3]; j++) {\n                    if (grid[i][j] == 0) {\n                        complete_set = new Set();\n                        // adding values for rows and columns\n                        for (let x = 0; x < 9; x++) {  \n                            // add the values it CAN NOT be             \n                            if (grid[i][x] != 0) {complete_set.add(grid[i][x])}\n                            if (grid[x][j] != 0) {complete_set.add(grid[x][j])}\n                        }\n                        // adding the values for the respective box\n                        // add the values it CAN NOT be             \n                        for (let x = sectors[sec][0]; x < sectors[sec][1]; x++) {\n                            for (let y = sectors[sec][2]; y < sectors[sec][3]; y++) {\n                                if (grid[x][y] != 0) {complete_set.add(grid[x][y])}\n                            }\n                        }\n                        possible_values[i][j] = [...complete_set] // possible_values[i][j] contains values it cannot be\n                        // possible_values[i][j] contains values it can be\n                        possible_values[i][j] = new Set([...all_values].filter(x => !possible_values[i][j].includes(x) ));\n                        if (possible_values[i][j].size == 1) {\n                            v = possible_values[i][j].values().next().value\n                            if (is_valid(grid, i, j, v)) {\n                                // console.log(\"found one\", v)\n                                implied_values.push([i, j, v])\n                                grid[i][j] = v\n                                flag = 1\n                            }\n                        }\n                    }       \n                }\n            }\n        }\n    }\n    return implied_values\n    // return {\"iv\": implied_values, \"g\": grid}\n}"]},"metadata":{},"sourceType":"module"}