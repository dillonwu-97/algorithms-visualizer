{"ast":null,"code":"import React from 'react';\nimport { backtrack, initialize_visited } from './general';\nimport '../../setup/global';\n\nvar heapq = require('heapq');\n\nexport default function astar(start_i, start_j, end_i, end_j, walls) {\n  var cmp = function (x, y) {\n    // console.log(x[0], y[0])\n    return x[0] < y[0];\n  };\n\n  let row_count = global.rc;\n  let col_count = global.cc;\n  let q = []; // using push and shift\n  // visited, all are initialized to null \n  // console.log(start_i, start_j, end_i, end_j, row_count)\n  // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n  let visited = initialize_visited(row_count, col_count);\n  let min_graph = initialize_visited(row_count, col_count);\n  let in_heap = initialize_visited(row_count, col_count);\n  heapq.push(q, [0, {\n    coord: [start_i, start_j],\n    count: 0,\n    prev: [start_i, start_j]\n  }], cmp);\n  let out_pre, out, distance;\n  let return_vals = []; // return the list of nodes that were visited in order\n  // TODO: the issue is that nodes that are being visited from suboptimal squares. as a result, we are not going from the best square\n\n  while (q.length != 0) {\n    out_pre = heapq.pop(q, cmp); // console.log(\"distance \", out_pre[0])\n\n    out = out_pre[1];\n    let out_i = out.coord[0];\n    let out_j = out.coord[1];\n    in_heap[out_i][out_j]--; // console.log(walls)\n    // console.log(typeof([13,25]), typeof(walls[0]))\n\n    if (walls.includes([out_i, out_j].toString())) {\n      continue;\n    }\n\n    return_vals.push([out_i, out_j]); // appending in each direction\n\n    if (visited[out_i][out_j] == 1 || min_graph[out_i][out_j] > out.count) {\n      min_graph[out_i][out_j] = out.count;\n      visited[out_i][out_j] = out.prev;\n    }\n\n    if (out_i == end_i && out_j == end_j) {\n      // console.log(min_graph)\n      console.log('astar count: ', out.count);\n      return_vals.push(backtrack(start_i, start_j, end_i, end_j, visited));\n      break;\n    } // console.log(out)\n\n\n    if (out_i > 0) {\n      distance = out.count + manhattan(end_i, out_i - 1, end_j, out_j);\n\n      if (visited[out_i - 1][out_j] == 0) {\n        heapq.push(q, [distance, {\n          coord: [out_i - 1, out_j],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n        visited[out_i - 1][out_j] = 1; // to mark the node as in the process of being visited\n\n        in_heap[out_i - 1][out_j] = distance;\n      } else if (distance < in_heap[out_i - 1][out_j]) {\n        in_heap[out_i - 1][out_j] = distance;\n        heapq.push(q, [distance, {\n          coord: [out_i - 1, out_j],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n      }\n    }\n\n    if (out_j > 0) {\n      distance = out.count + manhattan(end_i, out_i, end_j, out_j - 1);\n\n      if (visited[out_i][out_j - 1] == 0) {\n        heapq.push(q, [distance, {\n          coord: [out_i, out_j - 1],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n        visited[out_i][out_j - 1] = 1;\n        in_heap[out_i][out_j - 1] = distance;\n      } else if (distance < in_heap[out_i][out_j - 1]) {\n        in_heap[out_i][out_j - 1] = distance;\n        heapq.push(q, [distance, {\n          coord: [out_i, out_j - 1],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n      }\n    }\n\n    if (out_i < row_count - 1) {\n      distance = out.count + manhattan(end_i, out_i + 1, end_j, out_j);\n\n      if (visited[out_i + 1][out_j] == 0) {\n        heapq.push(q, [distance, {\n          coord: [out_i + 1, out_j],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n        visited[out_i + 1][out_j] = 1;\n        in_heap[out_i + 1][out_j] = distance;\n      } else if (distance < in_heap[out_i + 1][out_j]) {\n        in_heap[out_i + 1][out_j] = distance;\n        heapq.push(q, [distance, {\n          coord: [out_i + 1, out_j],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n      }\n    }\n\n    if (out_j < col_count - 1) {\n      distance = out.count + manhattan(end_i, out_i, end_j, out_j + 1);\n\n      if (visited[out_i][out_j + 1] == 0) {\n        heapq.push(q, [distance, {\n          coord: [out_i, out_j + 1],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n        visited[out_i][out_j + 1] = 1;\n        in_heap[out_i][out_j + 1] = distance;\n      } else if (distance < in_heap[out_i][out_j + 1]) {\n        in_heap[out_i][out_j + 1] = distance;\n        heapq.push(q, [distance, {\n          coord: [out_i, out_j + 1],\n          count: out.count + 1,\n          prev: out.coord\n        }], cmp);\n      }\n    }\n  }\n\n  return return_vals; // return_vals[-1] is the backtrack array; everything before that is order of traversal\n}\n\nfunction manhattan(x1, x2, y1, y2) {\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/pathfinder/algorithms/path_algs/astar.js"],"names":["React","backtrack","initialize_visited","heapq","require","astar","start_i","start_j","end_i","end_j","walls","cmp","x","y","row_count","global","rc","col_count","cc","q","visited","min_graph","in_heap","push","coord","count","prev","out_pre","out","distance","return_vals","length","pop","out_i","out_j","includes","toString","console","log","manhattan","x1","x2","y1","y2","Math","abs"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,SAAT,EAAoBC,kBAApB,QAA8C,WAA9C;AACA,OAAO,oBAAP;;AACA,IAAIC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AAGA,eAAe,SAASC,KAAT,CAAeC,OAAf,EAAwBC,OAAxB,EAAiCC,KAAjC,EAAwCC,KAAxC,EAA+CC,KAA/C,EAAsD;AAEjE,MAAIC,GAAG,GAAG,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC3B;AACA,WAAOD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAf;AACA,GAHE;;AAKA,MAAIC,SAAS,GAAGC,MAAM,CAACC,EAAvB;AACA,MAAIC,SAAS,GAAGF,MAAM,CAACG,EAAvB;AAEH,MAAIC,CAAC,GAAG,EAAR,CAVoE,CAUzD;AACX;AACG;AACA;;AAEA,MAAIC,OAAO,GAAGlB,kBAAkB,CAACY,SAAD,EAAYG,SAAZ,CAAhC;AACH,MAAII,SAAS,GAAGnB,kBAAkB,CAACY,SAAD,EAAYG,SAAZ,CAAlC;AACA,MAAIK,OAAO,GAAGpB,kBAAkB,CAACY,SAAD,EAAYG,SAAZ,CAAhC;AACAd,EAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAAC,CAAD,EAAI;AAACK,IAAAA,KAAK,EAAE,CAAClB,OAAD,EAAUC,OAAV,CAAR;AAA4BkB,IAAAA,KAAK,EAAE,CAAnC;AAAsCC,IAAAA,IAAI,EAAE,CAACpB,OAAD,EAAUC,OAAV;AAA5C,GAAJ,CAAd,EAAoFI,GAApF;AACA,MAAIgB,OAAJ,EAAaC,GAAb,EAAkBC,QAAlB;AACA,MAAIC,WAAW,GAAG,EAAlB,CApBoE,CAoB9C;AAEtB;;AACA,SAAMX,CAAC,CAACY,MAAF,IAAY,CAAlB,EAAqB;AACpBJ,IAAAA,OAAO,GAAGxB,KAAK,CAAC6B,GAAN,CAAUb,CAAV,EAAaR,GAAb,CAAV,CADoB,CAEpB;;AACMiB,IAAAA,GAAG,GAAGD,OAAO,CAAC,CAAD,CAAb;AACN,QAAIM,KAAK,GAAGL,GAAG,CAACJ,KAAJ,CAAU,CAAV,CAAZ;AACA,QAAIU,KAAK,GAAGN,GAAG,CAACJ,KAAJ,CAAU,CAAV,CAAZ;AACAF,IAAAA,OAAO,CAACW,KAAD,CAAP,CAAeC,KAAf,IANoB,CAOpB;AACA;;AACA,QAAIxB,KAAK,CAACyB,QAAN,CAAe,CAACF,KAAD,EAAQC,KAAR,EAAeE,QAAf,EAAf,CAAJ,EAA+C;AAC9C;AACA;;AACDN,IAAAA,WAAW,CAACP,IAAZ,CAAiB,CAACU,KAAD,EAAQC,KAAR,CAAjB,EAZoB,CAad;;AACA,QAAId,OAAO,CAACa,KAAD,CAAP,CAAeC,KAAf,KAAyB,CAAzB,IAA8Bb,SAAS,CAACY,KAAD,CAAT,CAAiBC,KAAjB,IAA0BN,GAAG,CAACH,KAAhE,EAAuE;AACnEJ,MAAAA,SAAS,CAACY,KAAD,CAAT,CAAiBC,KAAjB,IAA0BN,GAAG,CAACH,KAA9B;AACAL,MAAAA,OAAO,CAACa,KAAD,CAAP,CAAeC,KAAf,IAAwBN,GAAG,CAACF,IAA5B;AACH;;AACP,QAAIO,KAAK,IAAIzB,KAAT,IAAkB0B,KAAK,IAAIzB,KAA/B,EAAsC;AACrC;AACA4B,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BV,GAAG,CAACH,KAAjC;AACAK,MAAAA,WAAW,CAACP,IAAZ,CAAiBtB,SAAS,CAACK,OAAD,EAAUC,OAAV,EAAmBC,KAAnB,EAA0BC,KAA1B,EAAiCW,OAAjC,CAA1B;AACA;AACA,KAvBmB,CAwBpB;;;AACA,QAAIa,KAAK,GAAG,CAAZ,EAAe;AACdJ,MAAAA,QAAQ,GAAGD,GAAG,CAACH,KAAJ,GAAac,SAAS,CAAC/B,KAAD,EAAQyB,KAAK,GAAC,CAAd,EAAiBxB,KAAjB,EAAwByB,KAAxB,CAAjC;;AACA,UAAGd,OAAO,CAACa,KAAK,GAAC,CAAP,CAAP,CAAiBC,KAAjB,KAA2B,CAA9B,EAAiC;AAChC/B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAK,GAAC,CAAP,EAAUC,KAAV,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACAS,QAAAA,OAAO,CAAEa,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAA2B,CAA3B,CAFgC,CAEH;;AAC7BZ,QAAAA,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAA2BL,QAA3B;AACA,OAJD,MAIO,IAAIA,QAAQ,GAAGP,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,CAAf,EAAyC;AAC/CZ,QAAAA,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAA2BL,QAA3B;AACA1B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAK,GAAC,CAAP,EAAUC,KAAV,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACA;AACD;;AACD,QAAIuB,KAAK,GAAG,CAAZ,EAAc;AACbL,MAAAA,QAAQ,GAAGD,GAAG,CAACH,KAAJ,GAAac,SAAS,CAAC/B,KAAD,EAAQyB,KAAR,EAAexB,KAAf,EAAsByB,KAAK,GAAC,CAA5B,CAAjC;;AACA,UAAId,OAAO,CAACa,KAAD,CAAP,CAAeC,KAAK,GAAC,CAArB,KAA2B,CAA/B,EAAkC;AACjC/B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAD,EAAQC,KAAK,GAAC,CAAd,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACAS,QAAAA,OAAO,CAAEa,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAA2B,CAA3B;AACAZ,QAAAA,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAAyBL,QAAzB;AACA,OAJD,MAIO,IAAIA,QAAQ,GAAGP,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,CAAf,EAAyC;AAC/CZ,QAAAA,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAA2BL,QAA3B;AACA1B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAD,EAAQC,KAAK,GAAC,CAAd,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACA;AACD;;AACD,QAAIsB,KAAK,GAAGnB,SAAS,GAAC,CAAtB,EAAyB;AACxBe,MAAAA,QAAQ,GAAGD,GAAG,CAACH,KAAJ,GAAac,SAAS,CAAC/B,KAAD,EAAQyB,KAAK,GAAC,CAAd,EAAiBxB,KAAjB,EAAwByB,KAAxB,CAAjC;;AACA,UAAId,OAAO,CAACa,KAAK,GAAC,CAAP,CAAP,CAAiBC,KAAjB,KAA2B,CAA/B,EAAkC;AACjC/B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAK,GAAC,CAAP,EAAUC,KAAV,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACAS,QAAAA,OAAO,CAAEa,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAA2B,CAA3B;AACAZ,QAAAA,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAAyBL,QAAzB;AACA,OAJD,MAIO,IAAIA,QAAQ,GAAGP,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,CAAf,EAAyC;AAC/CZ,QAAAA,OAAO,CAAEW,KAAK,GAAC,CAAR,CAAP,CAAkBC,KAAlB,IAAyBL,QAAzB;AACA1B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAK,GAAC,CAAP,EAAUC,KAAV,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACA;AACD;;AACD,QAAIuB,KAAK,GAAGjB,SAAS,GAAC,CAAtB,EAAyB;AACxBY,MAAAA,QAAQ,GAAGD,GAAG,CAACH,KAAJ,GAAac,SAAS,CAAC/B,KAAD,EAAQyB,KAAR,EAAexB,KAAf,EAAsByB,KAAK,GAAC,CAA5B,CAAjC;;AACA,UAAId,OAAO,CAACa,KAAD,CAAP,CAAeC,KAAK,GAAC,CAArB,KAA2B,CAA/B,EAAkC;AACjC/B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAD,EAAQC,KAAK,GAAC,CAAd,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACAS,QAAAA,OAAO,CAAEa,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAA2B,CAA3B;AACAZ,QAAAA,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAAyBL,QAAzB;AACA,OAJD,MAIO,IAAIA,QAAQ,GAAGP,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,CAAf,EAAyC;AAC/CZ,QAAAA,OAAO,CAAEW,KAAF,CAAP,CAAgBC,KAAK,GAAC,CAAtB,IAAyBL,QAAzB;AACA1B,QAAAA,KAAK,CAACoB,IAAN,CAAWJ,CAAX,EAAc,CAACU,QAAD,EAAW;AAACL,UAAAA,KAAK,EAAC,CAACS,KAAD,EAAQC,KAAK,GAAC,CAAd,CAAP;AAAyBT,UAAAA,KAAK,EAAEG,GAAG,CAACH,KAAJ,GAAU,CAA1C;AAA6CC,UAAAA,IAAI,EAACE,GAAG,CAACJ;AAAtD,SAAX,CAAd,EAAwFb,GAAxF;AACA;AACD;AACD;;AACD,SAAOmB,WAAP,CA7FoE,CA6FjD;AAGnB;;AAED,SAASS,SAAT,CAAmBC,EAAnB,EAAuBC,EAAvB,EAA2BC,EAA3B,EAA+BC,EAA/B,EAAmC;AAC/B,SAAOC,IAAI,CAACC,GAAL,CAASL,EAAE,GAACC,EAAZ,IAAkBG,IAAI,CAACC,GAAL,CAASH,EAAE,GAACC,EAAZ,CAAzB;AACH","sourcesContent":["import React from 'react'\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\nvar heapq = require('heapq')\n\n\nexport default function astar(start_i, start_j, end_i, end_j, walls) {\n\n    var cmp = function(x, y) {\n\t\t// console.log(x[0], y[0])\n\t\treturn x[0] < y[0];\n\t}\n\n    let row_count = global.rc\n    let col_count = global.cc\n\n\tlet q = [] // using push and shift\n\t// visited, all are initialized to null \n    // console.log(start_i, start_j, end_i, end_j, row_count)\n    // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n    let visited = initialize_visited(row_count, col_count);\n\tlet min_graph = initialize_visited(row_count, col_count)\n\tlet in_heap = initialize_visited(row_count, col_count);\n\theapq.push(q, [0, {coord: [start_i, start_j], count: 0, prev: [start_i, start_j]}], cmp )\n\tlet out_pre, out, distance; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\n\t// TODO: the issue is that nodes that are being visited from suboptimal squares. as a result, we are not going from the best square\n\twhile(q.length != 0) {\n\t\tout_pre = heapq.pop(q, cmp)\n\t\t// console.log(\"distance \", out_pre[0])\n        out = out_pre[1]\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\tin_heap[out_i][out_j] --;\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n        // appending in each direction\n        if (visited[out_i][out_j] == 1 || min_graph[out_i][out_j] > out.count) {\n            min_graph[out_i][out_j] = out.count\n            visited[out_i][out_j] = out.prev\n        }\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log(min_graph)\n\t\t\tconsole.log('astar count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i-1, end_j, out_j)) \n\t\t\tif(visited[out_i-1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t} else if (distance < in_heap [out_i-1][out_j] ){\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j > 0){\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j-1))\n\t\t\tif (visited[out_i][out_j-1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j-1] = 1\n\t\t\t\tin_heap [out_i][out_j-1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j-1]) {\n\t\t\t\tin_heap [out_i][out_j-1] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_i < row_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i+1, end_j, out_j))\n\t\t\tif (visited[out_i+1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i+1][out_j] = 1\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t} else if (distance < in_heap [out_i+1][out_j]) {\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j < col_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j+1))\n\t\t\tif (visited[out_i][out_j+1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j+1] = 1\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j+1]) {\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n\nfunction manhattan(x1, x2, y1, y2) {\n    return Math.abs(x1-x2) + Math.abs(y1-y2)\n}"]},"metadata":{},"sourceType":"module"}