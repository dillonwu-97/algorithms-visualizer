{"ast":null,"code":"import React from'react';import{backtrack,initialize_visited}from'./general';import'../../setup/global';// TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n// takes in some start and end location\n// takes in the row and column size of the grid\nexport default function dfs(start_i,start_j,end_i,end_j,walls){var q=[];// using push and shift\nvar row_count=global.rc;var col_count=global.cc;// visited, all are initialized to null \n// console.log(start_i, start_j, end_i, end_j, row_count)\nvar visited=initialize_visited(row_count,col_count);q.push({coord:[start_i,start_j],count:0,prev:[start_i,start_j]});var out;var return_vals=[];// return the list of nodes that were visited in order\nwhile(q.length!=0){out=q.pop();var out_i=out.coord[0];var out_j=out.coord[1];// console.log(walls)\n// console.log(typeof([13,25]), typeof(walls[0]))\nif(walls.includes([out_i,out_j].toString())){continue;}if(visited[out_i][out_j]!=0){continue;}return_vals.push([out_i,out_j]);// appending in each direction\nvisited[out_i][out_j]=out.prev;if(out_i==end_i&&out_j==end_j){// console.log('ended')\nreturn_vals.push(backtrack(start_i,start_j,end_i,end_j,visited));break;}// console.log(out_i, out_j, out_i, out_j+1, out_i-1, out_j, out_i, out_j-1, out_i+1,)\nif(out_i<row_count-1&&visited[out_i+1][out_j]==0){q.push({coord:[out_i+1,out_j],count:out.count+1,prev:out.coord});// visited [out_i+1][out_j] = 1\n}if(out_j>0&&visited[out_i][out_j-1]==0){q.push({coord:[out_i,out_j-1],count:out.count+1,prev:out.coord});// visited [out_i][out_j-1] = 1\n}if(out_i>0&&visited[out_i-1][out_j]==0){q.push({coord:[out_i-1,out_j],count:out.count+1,prev:out.coord});// visited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n}if(out_j<col_count-1&&visited[out_i][out_j+1]==0){q.push({coord:[out_i,out_j+1],count:out.count+1,prev:out.coord});// visited [out_i][out_j+1] = 1\n}}return return_vals;// return_vals[-1] is the backtrack array; everything before that is order of traversal\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/algorithms/path_algs/dfs.js"],"names":["React","backtrack","initialize_visited","dfs","start_i","start_j","end_i","end_j","walls","q","row_count","global","rc","col_count","cc","visited","push","coord","count","prev","out","return_vals","length","pop","out_i","out_j","includes","toString"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\n\n// TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n\n\n// takes in some start and end location\n// takes in the row and column size of the grid\nexport default function dfs(start_i, start_j, end_i, end_j, walls) {\n\tlet q = [] // using push and shift\n\tlet row_count = global.rc\n\tlet col_count = global.cc\n\t// visited, all are initialized to null \n\t// console.log(start_i, start_j, end_i, end_j, row_count)\n\tlet visited = initialize_visited(row_count, col_count);\n\tq.push({coord: [start_i, start_j], count: 0, prev: [start_i, start_j]})\n\tlet out; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n\t\tout = q.pop()\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (visited[out_i][out_j] != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n\t\t// appending in each direction\n\t\tvisited[out_i][out_j] = out.prev\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log('ended')\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out_i, out_j, out_i, out_j+1, out_i-1, out_j, out_i, out_j-1, out_i+1,)\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i+1, out_j], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j-1], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i-1, out_j], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j+1], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n"]},"metadata":{},"sourceType":"module"}