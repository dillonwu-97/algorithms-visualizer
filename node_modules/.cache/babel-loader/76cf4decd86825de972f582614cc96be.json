{"ast":null,"code":"import React from 'react';\nimport '../../setup/global';\nexport default function random_maze() {\n  // create setup to check adjacencies\n  let visited = initialize_visited(global.rc, global.cc);\n  let maze = []; // build the maze\n  // can transform shape of map by changing value for this\n\n  for (let i = 0; i < global.rc; i++) {\n    for (let j = 0; j < global.cc; j++) {\n      if (Math.random() > .15) {\n        if (check_adjacencies(i, j, visited)) {\n          visited[i][j] = 1;\n        } // visited[i][j]=1\n\n      }\n    }\n  } // make sure there are no islands\n\n\n  for (let i = 0; i < global.cc; i++) {\n    maze.push([0, i]);\n    maze.push([global.rc - 1, i]);\n    visited[0][i] = 1;\n    visited[global.rc - 1][i] = 1;\n  }\n\n  for (let i = 0; i < global.rc; i++) {\n    maze.push([i, 0]);\n    maze.push([i, global.cc - 1]);\n    visited[i][0] = 1;\n    visited[i][global.cc - 1] = 1;\n  } // this is not changing\n\n\n  for (let i = 0; i < 2; i++) {\n    visited = remove_islands(visited);\n    visited = remove_islands_edge(visited); // console.log(visited)\n  } // for some reason, there is always something blocked on the last row so i'm just going to get rid of it\n\n\n  for (let i = 1; i < global.cc - 1; i++) {\n    if (Math.random() > .15) {\n      visited[global.rc - 2][i] = 0;\n    } // visited[global.rc-2][i] = 0\n\n  }\n\n  visited = remove_islands_edge(visited); // remove islands using second idea: tracing the walls to see if they touch\n\n  for (let i = 1; i < global.rc - 1; i++) {\n    for (let j = 1; j < global.cc - 1; j++) {\n      if (visited[i][j] == 1) {\n        maze.push([i, j]);\n      }\n    }\n  }\n\n  return maze;\n} // new strategy: \n// go along each edge of the graph and if you ever hit an edge, then create an opening?\n\nfunction remove_islands_edge(visited) {\n  let q = [];\n  let out, out_i, out_j, temp_i, temp_j, x, y;\n  let right_left_walls = [1, global.cc - 2];\n  let top_down_walls = [1, global.rc - 2]; // for \n\n  let checked = initialize_visited(global.rc, global.cc);\n\n  for (let j = 1; j > -1; j--) {\n    for (let i = 1; i < global.cc - 1; i++) {\n      // console.log(\"i is: \", i)\n      if (visited[top_down_walls[j]][i] == 1 && checked[top_down_walls[j]][i] == 0) {\n        q.push([top_down_walls[j], i]);\n\n        while (q.length != 0) {\n          out = q.shift();\n          out_i = out[0];\n          out_j = out[1]; // console.log(out_i, out_j, checked[out_i][out_j])\n          // condition: cannot be adjacent to each other\n          // wall detection mechanism\n\n          if (out_j in right_left_walls || out_i in top_down_walls) {\n            if (Math.abs(i - out_j) > 0 || Math.abs(top_down_walls[j] - out_i) > 0) {\n              // console.log(\"breakpoint \", out_i, out_j)\n              x = out_i;\n              y = out_j; // console.log (\"wtf \", y)\n\n              while (y > 0 && visited[x][y] == 1) {\n                visited[x][y] = 0;\n                y -= 1;\n              }\n\n              while (x > 0 && visited[x][out_j] == 1) {\n                visited[x][out_j] = 0;\n                x -= 1;\n              }\n\n              x = out_i;\n\n              while (out_j < global.cc && visited[x][out_j] == 1) {\n                visited[x][out_j] = 0;\n                out_j += 1;\n              }\n\n              while (out_i < global.rc && visited[out_i][out_j] == 1) {\n                visited[out_j][out_j] = 0;\n                out_i += 1;\n              }\n\n              visited[top_down_walls[j]][i] = 0;\n            }\n          } // add all adjacents including diagonals\n\n\n          for (let x = -1; x < 2; x++) {\n            for (let y = -1; y < 2; y++) {\n              temp_i = out_i + x;\n              temp_j = out_j + y;\n\n              if (visited[temp_i][temp_j] == 1 && checked[temp_i][temp_j] == 0 && temp_i != 0 && temp_j != 0 && temp_i != global.rc - 1 && temp_j != global.cc - 1) {\n                q.push([temp_i, temp_j]);\n                checked[temp_i][temp_j] = 1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return visited;\n}\n\nfunction remove_islands(visited) {\n  let q = []; // using push and shift\n\n  let out;\n  let out_i;\n  let out_j;\n  let checked = initialize_visited(global.rc, global.cc);\n\n  for (let i = 0; i < global.rc; i++) {\n    for (let j = 0; j < global.cc; j++) {\n      if (checked[i][j] == 0 && visited[i][j] == 0) {\n        q.push([i, j]);\n\n        while (q.length != 0) {\n          // console.log(visited)\n          out = q.shift();\n          out_i = out[0];\n          out_j = out[1];\n\n          if (out_i > 0 && checked[out_i - 1][out_j] == 0 && visited[out_i - 1][out_j] == 0) {\n            q.push([out_i - 1, out_j]);\n            checked[out_i - 1][out_j] = 1;\n          }\n\n          if (out_j > 0 && checked[out_i][out_j - 1] == 0 && visited[out_i][out_j - 1] == 0) {\n            q.push([out_i, out_j - 1]);\n            checked[out_i][out_j - 1] = 1;\n          }\n\n          if (out_i < global.rc - 1 && checked[out_i + 1][out_j] == 0 && visited[out_i + 1][out_j] == 0) {\n            q.push([out_i + 1, out_j]);\n            checked[out_i + 1][out_j] = 1;\n          }\n\n          if (out_j < global.cc - 1 && checked[out_i][out_j + 1] == 0 && visited[out_i][out_j + 1] == 0) {\n            q.push([out_i, out_j + 1]);\n            checked[out_i][out_j + 1] = 1;\n          } // console.log(visited)\n          // console.log(checked)\n\n        } // console.log(out_i, out_j)\n        // drill until you hit a 0 or are out of range\n        // need to make sure it is not drilling the borders\n\n\n        let o;\n\n        if (out_i + 1 < global.rc - 2 && visited[out_i + 1][out_j] == 1) {\n          o = drill(out_i + 1, out_j, visited, checked);\n        } else if (out_i - 1 > 1 && visited[out_i - 1][out_j] == 1) {\n          o = drill(out_i - 1, out_j, visited, checked);\n        } else if (out_j + 1 < global.cc - 2 && visited[out_i][out_j + 1] == 1) {\n          o = drill(out_i, out_j + 1, visited, checked);\n        } else if (out_j - 1 > 1 && visited[out_i][out_j - 1] == 1) {\n          o = drill(out_i, out_j - 1, visited, checked);\n        }\n\n        if (o !== undefined) {\n          visited = o.visited;\n          checked = o.checked;\n        } // console.log(o)\n\n      }\n    }\n  }\n\n  return visited;\n}\n\nfunction drill(i, j, visited, checked) {\n  visited[i][j] = 1;\n\n  while (i < global.rc - 1 && visited[i][j] == 1) {\n    // console.log(\"row \", i, j)\n    visited[i][j] = 0;\n    checked[i][j] = 0;\n    i += 1;\n  }\n\n  visited[i][j] = 1;\n\n  while (j < global.cc - 1 && visited[i][j] == 1) {\n    // console.log(\"column \", i,j)\n    visited[i][j] = 0;\n    checked[i][j] = 0;\n    j += 1;\n  } // while(i > 0 && visited[i][j] == 1) {\n  //     console.log(\"row \", i, j)\n  //     visited[i][j] = 0\n  //     i-=1\n  // }\n  // visited[i][j] = 1\n  // while(j < 0 && visited[i][j] == 1) {\n  //     console.log(\"column \", i,j)\n  //     visited[i][j] = 0\n  //     j-=1\n  // }\n\n\n  let o = {\n    visited,\n    checked\n  };\n  return o;\n} // transform shape of map by changing the values for this\n\n\nfunction check_adjacencies(row, col, visited) {\n  let count = 0;\n\n  for (let i = -1; i < 2; i++) {\n    for (let j = -1; j < 2; j++) {\n      try {\n        if (i == -1 && j == -1 || i == 1 && j == -1 || i == 1 && j == 1 || i == -1 && j == 1) {\n          if (visited[row + i][col + j] == 1) {\n            count += 2;\n          }\n        } else if (visited[row + i][col + j] == 1) {\n          count += 1;\n        } // console.log(count)\n\n      } catch {\n        count += 1;\n      }\n\n      if (count > 4) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction initialize_visited(row_count, col_count) {\n  var visited = new Array(row_count);\n\n  for (let i = 0; i < row_count; i++) {\n    visited[i] = new Array(col_count).fill(0);\n  }\n\n  return visited;\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/algorithms/maze_algs/random_maze.js"],"names":["React","random_maze","visited","initialize_visited","global","rc","cc","maze","i","j","Math","random","check_adjacencies","push","remove_islands","remove_islands_edge","q","out","out_i","out_j","temp_i","temp_j","x","y","right_left_walls","top_down_walls","checked","length","shift","abs","o","drill","undefined","row","col","count","row_count","col_count","Array","fill"],"mappings":"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","sourcesContent":["import React from 'react'\nimport '../../setup/global'\n\nexport default function random_maze() {\n    // create setup to check adjacencies\n    let visited = initialize_visited(global.rc, global.cc);\n    let maze = []\n    // build the maze\n    // can transform shape of map by changing value for this\n    for (let i = 0; i < global.rc; i++) {\n        for (let j = 0; j < global.cc; j++) {\n            if (Math.random() > .15) {\n                if (check_adjacencies(i, j, visited)) {\n                    visited[i][j] = 1\n                }\n                // visited[i][j]=1\n            }\n        }\n    }\n\n    // make sure there are no islands\n\n    for (let i = 0; i < global.cc; i++) {\n        maze.push([0,i])\n        maze.push([global.rc-1,i])\n        visited[0][i] = 1\n        visited[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        maze.push([i, 0])\n        maze.push([i, global.cc-1])\n        visited[i][0] = 1\n        visited[i][global.cc-1] = 1\n    }\n\n    // this is not changing\n    for (let i = 0; i < 2; i++) {\n        visited = remove_islands(visited)\n        visited = remove_islands_edge(visited)\n        // console.log(visited)\n    }\n    // for some reason, there is always something blocked on the last row so i'm just going to get rid of it\n    for (let i = 1; i < global.cc-1; i++) {\n        if (Math.random() > .15) {\n            visited[global.rc-2][i] = 0\n        }\n            // visited[global.rc-2][i] = 0\n    }\n    visited = remove_islands_edge(visited)\n\n    // remove islands using second idea: tracing the walls to see if they touch\n\n    \n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if(visited[i][j] == 1) {\n                maze.push([i,j])\n            }\n        }\n    }\n    \n    return maze\n}\n\n// new strategy: \n// go along each edge of the graph and if you ever hit an edge, then create an opening?\nfunction remove_islands_edge (visited) {\n    let q = []\n    let out, out_i, out_j, temp_i, temp_j, x, y;\n    let right_left_walls = [1, global.cc-2]\n    let top_down_walls = [1, global.rc-2]\n\n    // for \n    let checked = initialize_visited(global.rc, global.cc)\n    for (let j = 1; j > -1; j--) {        \n        for (let i = 1; i < global.cc-1; i++) {\n            // console.log(\"i is: \", i)\n            if (visited[top_down_walls[j]][i] == 1 && checked[top_down_walls[j]][i] == 0) {\n                q.push([top_down_walls[j],i])\n                while (q.length != 0) {\n                    out = q.shift()\n                    out_i = out[0]\n                    out_j = out[1]\n                    // console.log(out_i, out_j, checked[out_i][out_j])\n                    // condition: cannot be adjacent to each other\n                    // wall detection mechanism\n                    if (out_j in right_left_walls || out_i in top_down_walls) {\n                        if (Math.abs(i - out_j) > 0 || Math.abs(top_down_walls[j] -out_i) > 0) {\n                            // console.log(\"breakpoint \", out_i, out_j)\n                            \n                            x = out_i\n                            y = out_j\n                            // console.log (\"wtf \", y)\n                            while (y > 0 && visited[x][y] == 1) {\n                                visited[x][y] = 0\n                                y-=1\n                            }\n                            while (x > 0 && visited[x][out_j] == 1) {\n                                visited[x][out_j] = 0\n                                x-=1\n                            }\n                            x = out_i\n                            while (out_j < global.cc && visited[x][out_j] == 1) {\n                                visited[x][out_j] = 0\n                                out_j+=1\n                            }\n                            while (out_i < global.rc && visited[out_i][out_j] == 1) {\n                                visited[out_j][out_j] = 0\n                                out_i+=1\n                            }\n                            visited[top_down_walls[j]][i] = 0\n                        }\n                    }\n                    // add all adjacents including diagonals\n                    for (let x = -1; x < 2; x++) {\n                        for (let y = -1; y < 2; y++) {\n                            temp_i = out_i + x\n                            temp_j = out_j + y\n                            if (visited[temp_i][temp_j] == 1 && checked[temp_i][temp_j] == 0 && temp_i != 0 && temp_j != 0 && temp_i != global.rc-1 && temp_j!=global.cc-1) {\n                                q.push([temp_i,temp_j])\n                                checked[temp_i] [temp_j] = 1\n                            } \n                        }\n                    }\n                }\n            }\n        }\n    }\n    return visited\n}\n\nfunction remove_islands(visited) {\n\tlet q = [] // using push and shift\n    let out; \n    let out_i;\n    let out_j;\n    let checked = initialize_visited(global.rc, global.cc)\n    for (let i = 0; i < global.rc; i++) {\n        for (let j = 0; j < global.cc; j++) {\n            if (checked[i][j] == 0 && visited[i][j] == 0) {  \n                q.push([i, j])\n                while (q.length!=0) {\n                    // console.log(visited)\n                    out = q.shift()\n                    out_i = out[0]\n                    out_j = out[1]\n                    if (out_i > 0 && checked[out_i-1][out_j] == 0 && visited[out_i-1][out_j] == 0) {\n                        q.push([out_i-1, out_j])\n                        checked[out_i-1][out_j] = 1\n                    }\n                    if (out_j > 0 && checked[out_i][out_j-1] == 0 && visited[out_i][out_j-1] == 0) {\n                        q.push([out_i, out_j-1])\n                        checked[out_i][out_j-1] = 1\n                    }\n                    if (out_i < global.rc-1 && checked[out_i+1][out_j] == 0 && visited[out_i+1][out_j] == 0) {\n                        q.push([out_i+1, out_j])\n                        checked[out_i+1][out_j] = 1\n                    }\n                    if (out_j < global.cc-1 && checked[out_i][out_j+1] == 0 && visited[out_i][out_j+1] == 0) {\n                        q.push([out_i, out_j+1])\n                        checked[out_i][out_j+1] = 1\n                    }    \n                    // console.log(visited)\n                    // console.log(checked)\n                }\n                // console.log(out_i, out_j)\n                // drill until you hit a 0 or are out of range\n                // need to make sure it is not drilling the borders\n\n                let o;\n                if (out_i+1 < global.rc-2 && visited[out_i+1][out_j] == 1) {\n                    o = drill (out_i+1, out_j, visited, checked)\n                } else if (out_i-1 > 1 && visited[out_i-1][out_j]==1){\n                    o = drill (out_i-1, out_j, visited, checked)\n                } else if (out_j+1 < global.cc-2 && visited[out_i][out_j+1] == 1) {\n                    o = drill (out_i, out_j+1, visited, checked)\n                } else if (out_j-1 > 1 && visited[out_i][out_j-1] == 1) {\n                    o = drill (out_i, out_j-1, visited, checked)\n                }\n                if (o !== undefined) {\n                    visited = o.visited\n                    checked = o.checked\n                }\n                // console.log(o)\n\n                \n            }\n        }\n    }\n    return visited\n\n}\n\nfunction drill(i, j,visited, checked) {\n\n    visited[i][j] = 1\n    while(i < global.rc-1 && visited[i][j] == 1) {\n        // console.log(\"row \", i, j)\n        visited[i][j] = 0\n        checked[i][j] = 0\n        i+=1\n    }\n    visited[i][j] = 1\n    while(j < global.cc-1 && visited[i][j] == 1) {\n        // console.log(\"column \", i,j)\n        visited[i][j] = 0\n        checked[i][j] = 0\n        j+=1\n    }\n    // while(i > 0 && visited[i][j] == 1) {\n    //     console.log(\"row \", i, j)\n    //     visited[i][j] = 0\n    //     i-=1\n    // }\n    // visited[i][j] = 1\n    // while(j < 0 && visited[i][j] == 1) {\n    //     console.log(\"column \", i,j)\n    //     visited[i][j] = 0\n    //     j-=1\n    // }\n    let o = {visited, checked}\n    return o\n}\n\n\n// transform shape of map by changing the values for this\nfunction check_adjacencies(row, col, visited) {\n    let count = 0\n    \n    for (let i = -1; i < 2; i++) {\n        for (let j = -1; j < 2; j++) {\n            try {\n                if (i==-1 && j == -1 || i == 1 && j == -1 || i==1 && j==1 || i==-1&&j==1) {\n                    if (visited[row+i][col+j] == 1) {\n                        count +=2;\n                    }\n                } else if (visited[row + i][col + j] == 1) {\n                    count+=1;\n                }\n                // console.log(count)\n            } catch {\n                count +=1;\n            }\n            if (count >4) {\n                return false\n            }\n        }\n    }\n    return true\n\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n"]},"metadata":{},"sourceType":"module"}