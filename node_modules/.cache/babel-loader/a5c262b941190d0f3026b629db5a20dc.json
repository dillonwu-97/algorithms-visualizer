{"ast":null,"code":"import React from'react';import{backtrack,initialize_visited}from'./general';import'../../setup/global';var heapq=require('heapq');export default function astar(start_i,start_j,end_i,end_j,walls){var cmp=function cmp(x,y){// console.log(x[0], y[0])\nreturn x[0]<y[0];};var row_count=global.rc;var col_count=global.cc;var q=[];// using push and shift\n// visited, all are initialized to null \n// console.log(start_i, start_j, end_i, end_j, row_count)\n// heapq.push(heap, [-3, {a:1, b:2}], cmp);\nvar visited=initialize_visited(row_count,col_count);var min_graph=initialize_visited(row_count,col_count);var in_heap=initialize_visited(row_count,col_count);heapq.push(q,[0,{coord:[start_i,start_j],count:0,prev:[start_i,start_j]}],cmp);var out_pre,out,distance;var return_vals=[];// return the list of nodes that were visited in order\n// TODO: the issue is that nodes that are being visited from suboptimal squares. as a result, we are not going from the best square\nwhile(q.length!=0){out_pre=heapq.pop(q,cmp);// console.log(\"distance \", out_pre[0])\nout=out_pre[1];var out_i=out.coord[0];var out_j=out.coord[1];in_heap[out_i][out_j]--;// console.log(walls)\n// console.log(typeof([13,25]), typeof(walls[0]))\nif(walls.includes([out_i,out_j].toString())){continue;}return_vals.push([out_i,out_j]);// appending in each direction\nif(visited[out_i][out_j]==1||min_graph[out_i][out_j]>out.count){min_graph[out_i][out_j]=out.count;visited[out_i][out_j]=out.prev;}if(out_i==end_i&&out_j==end_j){// console.log(min_graph)\nconsole.log('astar count: ',out.count);return_vals.push(backtrack(start_i,start_j,end_i,end_j,visited));break;}// console.log(out)\nif(out_i>0){distance=out.count+manhattan(end_i,out_i-1,end_j,out_j);if(visited[out_i-1][out_j]==0){heapq.push(q,[distance,{coord:[out_i-1,out_j],count:out.count+1,prev:out.coord}],cmp);visited[out_i-1][out_j]=1;// to mark the node as in the process of being visited\nin_heap[out_i-1][out_j]=distance;}else if(distance<in_heap[out_i-1][out_j]){in_heap[out_i-1][out_j]=distance;heapq.push(q,[distance,{coord:[out_i-1,out_j],count:out.count+1,prev:out.coord}],cmp);}}if(out_j>0){distance=out.count+manhattan(end_i,out_i,end_j,out_j-1);if(visited[out_i][out_j-1]==0){heapq.push(q,[distance,{coord:[out_i,out_j-1],count:out.count+1,prev:out.coord}],cmp);visited[out_i][out_j-1]=1;in_heap[out_i][out_j-1]=distance;}else if(distance<in_heap[out_i][out_j-1]){in_heap[out_i][out_j-1]=distance;heapq.push(q,[distance,{coord:[out_i,out_j-1],count:out.count+1,prev:out.coord}],cmp);}}if(out_i<row_count-1){distance=out.count+manhattan(end_i,out_i+1,end_j,out_j);if(visited[out_i+1][out_j]==0){heapq.push(q,[distance,{coord:[out_i+1,out_j],count:out.count+1,prev:out.coord}],cmp);visited[out_i+1][out_j]=1;in_heap[out_i+1][out_j]=distance;}else if(distance<in_heap[out_i+1][out_j]){in_heap[out_i+1][out_j]=distance;heapq.push(q,[distance,{coord:[out_i+1,out_j],count:out.count+1,prev:out.coord}],cmp);}}if(out_j<col_count-1){distance=out.count+manhattan(end_i,out_i,end_j,out_j+1);if(visited[out_i][out_j+1]==0){heapq.push(q,[distance,{coord:[out_i,out_j+1],count:out.count+1,prev:out.coord}],cmp);visited[out_i][out_j+1]=1;in_heap[out_i][out_j+1]=distance;}else if(distance<in_heap[out_i][out_j+1]){in_heap[out_i][out_j+1]=distance;heapq.push(q,[distance,{coord:[out_i,out_j+1],count:out.count+1,prev:out.coord}],cmp);}}}return return_vals;// return_vals[-1] is the backtrack array; everything before that is order of traversal\n}function manhattan(x1,x2,y1,y2){return Math.abs(x1-x2)+Math.abs(y1-y2);}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/algorithms/path_algs/astar.js"],"names":["React","backtrack","initialize_visited","heapq","require","astar","start_i","start_j","end_i","end_j","walls","cmp","x","y","row_count","global","rc","col_count","cc","q","visited","min_graph","in_heap","push","coord","count","prev","out_pre","out","distance","return_vals","length","pop","out_i","out_j","includes","toString","console","log","manhattan","x1","x2","y1","y2","Math","abs"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\nvar heapq = require('heapq')\n\n\nexport default function astar(start_i, start_j, end_i, end_j, walls) {\n\n    var cmp = function(x, y) {\n\t\t// console.log(x[0], y[0])\n\t\treturn x[0] < y[0];\n\t}\n\n    let row_count = global.rc\n    let col_count = global.cc\n\n\tlet q = [] // using push and shift\n\t// visited, all are initialized to null \n    // console.log(start_i, start_j, end_i, end_j, row_count)\n    // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n    let visited = initialize_visited(row_count, col_count);\n\tlet min_graph = initialize_visited(row_count, col_count)\n\tlet in_heap = initialize_visited(row_count, col_count);\n\theapq.push(q, [0, {coord: [start_i, start_j], count: 0, prev: [start_i, start_j]}], cmp )\n\tlet out_pre, out, distance; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\n\t// TODO: the issue is that nodes that are being visited from suboptimal squares. as a result, we are not going from the best square\n\twhile(q.length != 0) {\n\t\tout_pre = heapq.pop(q, cmp)\n\t\t// console.log(\"distance \", out_pre[0])\n        out = out_pre[1]\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\tin_heap[out_i][out_j] --;\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n        // appending in each direction\n        if (visited[out_i][out_j] == 1 || min_graph[out_i][out_j] > out.count) {\n            min_graph[out_i][out_j] = out.count\n            visited[out_i][out_j] = out.prev\n        }\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log(min_graph)\n\t\t\tconsole.log('astar count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i-1, end_j, out_j)) \n\t\t\tif(visited[out_i-1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t} else if (distance < in_heap [out_i-1][out_j] ){\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j > 0){\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j-1))\n\t\t\tif (visited[out_i][out_j-1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j-1] = 1\n\t\t\t\tin_heap [out_i][out_j-1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j-1]) {\n\t\t\t\tin_heap [out_i][out_j-1] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_i < row_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i+1, end_j, out_j))\n\t\t\tif (visited[out_i+1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i+1][out_j] = 1\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t} else if (distance < in_heap [out_i+1][out_j]) {\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j < col_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j+1))\n\t\t\tif (visited[out_i][out_j+1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j+1] = 1\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j+1]) {\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n\nfunction manhattan(x1, x2, y1, y2) {\n    return Math.abs(x1-x2) + Math.abs(y1-y2)\n}"]},"metadata":{},"sourceType":"module"}