{"ast":null,"code":"import React from 'react';\nimport '../../setup/global';\n\nvar disjointSet = require('disjoint-set');\n/*\nCreate a list of all walls, and create a set for each cell, each containing just that one cell.\nFor each wall, in some random order:\nIf the cells divided by this wall belong to distinct sets:\nRemove the current wall.\nJoin the sets of the formerly divided cells.\n*/\n// global.rc = 19\n// global.cc = 19\n// random_kruskal()\n\n\nexport default function random_kruskal() {\n  // create setup to check adjacencies\n  let set = disjointSet();\n  let visited = initialize_visited(global.rc, global.cc);\n  let walls = initialize_visited(global.rc, global.cc);\n  let x, y; // randomize array\n\n  let points = [],\n      maze = [];\n\n  for (let i = 1; i < global.rc - 1; i++) {\n    for (let j = 1; j < global.cc - 1; j++) {\n      if (j % 2 == 1 && i % 2 == 1) {\n        // need to connect all of the spaces\n        visited[i][j] = {\n          \"i\": i,\n          \"j\": j\n        };\n        set.add(visited[i][j]);\n      } else {\n        walls[i][j] = 1;\n        points.push([i, j]); // build min spanning tree using these points\n      }\n    }\n  }\n\n  for (let i = 0; i < global.cc; i++) {\n    walls[0][i] = 1;\n    walls[global.rc - 1][i] = 1;\n  }\n\n  for (let i = 0; i < global.rc; i++) {\n    walls[i][0] = 1;\n    walls[i][global.cc - 1] = 1;\n  } // for (let i = 0; i < global.rc; i++) {\n  //     console.log(walls[i].toString())\n  //     // console.log('\\n')\n  // }\n\n\n  points = shuffle(points);\n  let out_l, out_r; // disjoint set is now randomized and they are all walls\n\n  for (let i = 0; i < points.length; i++) {\n    x = points[i][0];\n    y = points[i][1];\n\n    if (walls[x + 1][y] == 0 && walls[x - 1][y] == 0) {\n      out_l = visited[x + 1][y];\n      out_r = visited[x - 1][y];\n\n      if (!set.connected(out_l, out_r)) {\n        // console.log(x, y)\n        walls[x][y] = 0;\n        set.union(out_l, out_r);\n        maze.push([x + 1, y], [x, y], [x - 1, y]);\n      }\n    } else if (walls[x][y + 1] == 0 && walls[x][y - 1] == 0) {\n      out_l = visited[x][y + 1];\n      out_r = visited[x][y - 1];\n\n      if (!set.connected(out_l, out_r)) {\n        // console.log(x,y)\n        walls[x][y] = 0;\n        set.union(out_l, out_r);\n        maze.push([x, y + 1], [x, y], [x, y - 1]);\n      }\n    }\n  } // for (let i = 0; i < global.rc; i++) {\n  //     console.log(walls[i].toString())\n  //     // console.log('\\n')\n  // }\n  // console.log(set.extract())\n\n\n  let ret_walls = [];\n\n  for (let i = 0; i < walls.length; i++) {\n    for (let j = 0; j < walls[0].length; j++) {\n      if (walls[i][j] == 1) {\n        ret_walls.push([i, j]);\n      }\n    }\n  } // console.log(maze)\n  // console.log( {\"maze\": maze, \"walls\": ret_walls})\n\n\n  return {\n    \"maze\": maze,\n    \"walls\": ret_walls\n  };\n}\n\nfunction shuffle(a) {\n  var j, x, i;\n\n  for (let i = a.length - 1; i > 0; i--) {\n    j = Math.floor(Math.random() * (i + 1));\n    x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n\n  return a;\n}\n\nfunction initialize_visited(row_count, col_count) {\n  var visited = new Array(row_count);\n\n  for (let i = 0; i < row_count; i++) {\n    visited[i] = new Array(col_count).fill(0);\n  }\n\n  return visited;\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/pathfinder/algorithms/maze_algs/random_kruskal.js"],"names":["React","disjointSet","require","random_kruskal","set","visited","initialize_visited","global","rc","cc","walls","x","y","points","maze","i","j","add","push","shuffle","out_l","out_r","length","connected","union","ret_walls","a","Math","floor","random","row_count","col_count","Array","fill"],"mappings":"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","sourcesContent":["import React from 'react'\nimport '../../setup/global'\nvar disjointSet = require('disjoint-set')\n\n/*\nCreate a list of all walls, and create a set for each cell, each containing just that one cell.\nFor each wall, in some random order:\nIf the cells divided by this wall belong to distinct sets:\nRemove the current wall.\nJoin the sets of the formerly divided cells.\n*/\n// global.rc = 19\n// global.cc = 19\n// random_kruskal()\nexport default function random_kruskal() {\n    // create setup to check adjacencies\n    let set = disjointSet()\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n    let x, y\n    // randomize array\n    let points = [], maze = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                // need to connect all of the spaces\n                visited[i][j] = {\"i\":i, \"j\":j}\n                set.add(visited[i][j])\n            } else {\n                walls[i][j] = 1\n                points.push([i,j]) // build min spanning tree using these points\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    points = shuffle(points)\n\n    let out_l, out_r\n    // disjoint set is now randomized and they are all walls\n    for (let i = 0; i < points.length; i ++) {\n        x = points[i][0]\n        y = points[i][1]\n        if (walls[x+1][y] == 0 && walls[x-1][y] == 0){\n            out_l = visited[x+1][y]\n            out_r = visited[x-1][y]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x, y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x+1,y], [x,y], [x-1,y])\n            }\n        } else if (walls[x][y+1] == 0 && walls[x][y-1] == 0) {\n            out_l = visited[x][y+1]\n            out_r = visited[x][y-1]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x,y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x,y+1], [x,y],[x,y-1])\n            }\n        }\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    \n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n\n    // console.log(maze)\n    // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n"]},"metadata":{},"sourceType":"module"}