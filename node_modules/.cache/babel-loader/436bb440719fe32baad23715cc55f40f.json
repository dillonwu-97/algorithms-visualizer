{"ast":null,"code":"import React from 'react';\nimport { backtrack, initialize_visited } from './general';\nimport '../../setup/global'; // TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n// takes in some start and end location\n// takes in the row and column size of the grid\n\nexport default function bfs(start_i, start_j, end_i, end_j, walls) {\n  let q = []; // using push and shift\n\n  let row_count = global.rc;\n  let col_count = global.cc; // visited, all are initialized to null \n  // console.log(start_i, start_j, end_i, end_j, row_count)\n\n  let visited = initialize_visited(row_count, col_count);\n  q.push({\n    coord: [start_i, start_j],\n    count: 0,\n    prev: [start_i, start_j]\n  });\n  let out;\n  let return_vals = []; // return the list of nodes that were visited in order\n\n  while (q.length != 0) {\n    out = q.shift();\n    let out_i = out.coord[0];\n    let out_j = out.coord[1]; // console.log(walls)\n    // console.log(typeof([13,25]), typeof(walls[0]))\n\n    if (walls.includes([out_i, out_j].toString())) {\n      continue;\n    }\n\n    return_vals.push([out_i, out_j]); // appending in each direction\n\n    visited[out_i][out_j] = out.prev;\n\n    if (out_i == end_i && out_j == end_j) {\n      console.log('bfs count: ', out.count);\n      return_vals.push(backtrack(start_i, start_j, end_i, end_j, visited));\n      break;\n    } // console.log(out)\n\n\n    if (out_i > 0 && visited[out_i - 1][out_j] == 0) {\n      q.push({\n        coord: [out_i - 1, out_j],\n        count: out.count + 1,\n        prev: out.coord\n      });\n      visited[out_i - 1][out_j] = 1; // to mark the node as in the process of being visited\n    }\n\n    if (out_j > 0 && visited[out_i][out_j - 1] == 0) {\n      q.push({\n        coord: [out_i, out_j - 1],\n        count: out.count + 1,\n        prev: out.coord\n      });\n      visited[out_i][out_j - 1] = 1;\n    }\n\n    if (out_i < row_count - 1 && visited[out_i + 1][out_j] == 0) {\n      q.push({\n        coord: [out_i + 1, out_j],\n        count: out.count + 1,\n        prev: out.coord\n      });\n      visited[out_i + 1][out_j] = 1;\n    }\n\n    if (out_j < col_count - 1 && visited[out_i][out_j + 1] == 0) {\n      q.push({\n        coord: [out_i, out_j + 1],\n        count: out.count + 1,\n        prev: out.coord\n      });\n      visited[out_i][out_j + 1] = 1;\n    }\n  }\n\n  return return_vals; // return_vals[-1] is the backtrack array; everything before that is order of traversal\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/pathfinder/algorithms/path_algs/bfs.js"],"names":["React","backtrack","initialize_visited","bfs","start_i","start_j","end_i","end_j","walls","q","row_count","global","rc","col_count","cc","visited","push","coord","count","prev","out","return_vals","length","shift","out_i","out_j","includes","toString","console","log"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\n\n\n// TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n\n\n// takes in some start and end location\n// takes in the row and column size of the grid\nexport default function bfs(start_i, start_j, end_i, end_j, walls) {\n\tlet q = [] // using push and shift\n\tlet row_count = global.rc\n\tlet col_count = global.cc\n\t// visited, all are initialized to null \n\t// console.log(start_i, start_j, end_i, end_j, row_count)\n\tlet visited = initialize_visited(row_count, col_count);\n\tq.push({coord: [start_i, start_j], count: 0, prev: [start_i, start_j]})\n\tlet out; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n\t\tout = q.shift()\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n\t\t// appending in each direction\n\t\tvisited[out_i][out_j] = out.prev\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\tconsole.log('bfs count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i-1, out_j], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j-1], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i+1, out_j], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j+1], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n"]},"metadata":{},"sourceType":"module"}