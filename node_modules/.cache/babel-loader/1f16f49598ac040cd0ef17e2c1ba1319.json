{"ast":null,"code":"import React from'react';import'../../setup/global';var disjointSet=require('disjoint-set');/*\nCreate a list of all walls, and create a set for each cell, each containing just that one cell.\nFor each wall, in some random order:\nIf the cells divided by this wall belong to distinct sets:\nRemove the current wall.\nJoin the sets of the formerly divided cells.\n*/ // global.rc = 19\n// global.cc = 19\n// random_kruskal()\nexport default function random_kruskal(){// create setup to check adjacencies\nvar set=disjointSet();var visited=initialize_visited(global.rc,global.cc);var walls=initialize_visited(global.rc,global.cc);var x,y;// randomize array\nvar points=[],maze=[];for(var i=1;i<global.rc-1;i++){for(var j=1;j<global.cc-1;j++){if(j%2==1&&i%2==1){// need to connect all of the spaces\nvisited[i][j]={\"i\":i,\"j\":j};set.add(visited[i][j]);}else{walls[i][j]=1;points.push([i,j]);// build min spanning tree using these points\n}}}for(var _i=0;_i<global.cc;_i++){walls[0][_i]=1;walls[global.rc-1][_i]=1;}for(var _i2=0;_i2<global.rc;_i2++){walls[_i2][0]=1;walls[_i2][global.cc-1]=1;}// for (let i = 0; i < global.rc; i++) {\n//     console.log(walls[i].toString())\n//     // console.log('\\n')\n// }\npoints=shuffle(points);var out_l,out_r;// disjoint set is now randomized and they are all walls\nfor(var _i3=0;_i3<points.length;_i3++){x=points[_i3][0];y=points[_i3][1];if(walls[x+1][y]==0&&walls[x-1][y]==0){out_l=visited[x+1][y];out_r=visited[x-1][y];if(!set.connected(out_l,out_r)){// console.log(x, y)\nwalls[x][y]=0;set.union(out_l,out_r);maze.push([x+1,y],[x,y],[x-1,y]);}}else if(walls[x][y+1]==0&&walls[x][y-1]==0){out_l=visited[x][y+1];out_r=visited[x][y-1];if(!set.connected(out_l,out_r)){// console.log(x,y)\nwalls[x][y]=0;set.union(out_l,out_r);maze.push([x,y+1],[x,y],[x,y-1]);}}}// for (let i = 0; i < global.rc; i++) {\n//     console.log(walls[i].toString())\n//     // console.log('\\n')\n// }\n// console.log(set.extract())\nvar ret_walls=[];for(var _i4=0;_i4<walls.length;_i4++){for(var _j=0;_j<walls[0].length;_j++){if(walls[_i4][_j]==1){ret_walls.push([_i4,_j]);}}}// console.log(maze)\n// console.log( {\"maze\": maze, \"walls\": ret_walls})\nreturn{\"maze\":maze,\"walls\":ret_walls};}function shuffle(a){var j,x,i;for(var _i5=a.length-1;_i5>0;_i5--){j=Math.floor(Math.random()*(_i5+1));x=a[_i5];a[_i5]=a[j];a[j]=x;}return a;}function initialize_visited(row_count,col_count){var visited=new Array(row_count);for(var i=0;i<row_count;i++){visited[i]=new Array(col_count).fill(0);}return visited;}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/algorithms/maze_algs/random_kruskal.js"],"names":["React","disjointSet","require","random_kruskal","set","visited","initialize_visited","global","rc","cc","walls","x","y","points","maze","i","j","add","push","shuffle","out_l","out_r","length","connected","union","ret_walls","a","Math","floor","random","row_count","col_count","Array","fill"],"mappings":"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","sourcesContent":["import React from 'react'\nimport '../../setup/global'\nvar disjointSet = require('disjoint-set')\n\n/*\nCreate a list of all walls, and create a set for each cell, each containing just that one cell.\nFor each wall, in some random order:\nIf the cells divided by this wall belong to distinct sets:\nRemove the current wall.\nJoin the sets of the formerly divided cells.\n*/\n// global.rc = 19\n// global.cc = 19\n// random_kruskal()\nexport default function random_kruskal() {\n    // create setup to check adjacencies\n    let set = disjointSet()\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n    let x, y\n    // randomize array\n    let points = [], maze = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                // need to connect all of the spaces\n                visited[i][j] = {\"i\":i, \"j\":j}\n                set.add(visited[i][j])\n            } else {\n                walls[i][j] = 1\n                points.push([i,j]) // build min spanning tree using these points\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    points = shuffle(points)\n\n    let out_l, out_r\n    // disjoint set is now randomized and they are all walls\n    for (let i = 0; i < points.length; i ++) {\n        x = points[i][0]\n        y = points[i][1]\n        if (walls[x+1][y] == 0 && walls[x-1][y] == 0){\n            out_l = visited[x+1][y]\n            out_r = visited[x-1][y]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x, y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x+1,y], [x,y], [x-1,y])\n            }\n        } else if (walls[x][y+1] == 0 && walls[x][y-1] == 0) {\n            out_l = visited[x][y+1]\n            out_r = visited[x][y-1]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x,y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x,y+1], [x,y],[x,y-1])\n            }\n        }\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    \n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n\n    // console.log(maze)\n    // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n"]},"metadata":{},"sourceType":"module"}