{"ast":null,"code":"import React from 'react';\nimport '../../setup/global'; // global.rc = 31\n// global.cc = 51\n// random_prims()\n\n/*\nChoose any vertex at random and add it to the UST.\nSelect any vertex that is not already in the UST and perform a random walk until you encounter a vertex that is in the UST.\nAdd the vertices and edges touched in the random walk to the UST.\nRepeat 2 and 3 until all vertices have been added to the UST.\n*/\n// wilson()\n\nexport default function wilson() {\n  // function wilson () {\n  let visited = initialize_visited(global.rc, global.cc);\n  let walls = initialize_visited(global.rc, global.cc);\n  let x, y, q, out; // randomize array\n\n  let maze = [],\n      total_vertices = 0,\n      to_visit = [];\n\n  for (let i = 1; i < global.rc - 1; i++) {\n    for (let j = 1; j < global.cc - 1; j++) {\n      if (j % 2 == 1 && i % 2 == 1) {\n        // need to connect all of the spaces\n        total_vertices++;\n        to_visit.push([i, j]);\n      } else {\n        walls[i][j] = 1;\n      }\n    }\n  }\n\n  for (let i = 0; i < global.cc; i++) {\n    walls[0][i] = 1;\n    walls[global.rc - 1][i] = 1;\n  }\n\n  for (let i = 0; i < global.rc; i++) {\n    walls[i][0] = 1;\n    walls[i][global.cc - 1] = 1;\n  }\n\n  to_visit = shuffle(to_visit);\n  let rand_i = 2 * Math.floor(Math.random() * Math.floor((global.rc - 1) / 2)) + 1;\n  let rand_j = 2 * Math.floor(Math.random() * Math.floor((global.cc - 1) / 2)) + 1;\n  /*\n  algorithm:\n  two dictionaries: current and completed\n  if i, j in current ever sees itself, backtrack\n  backtrack algorithm gets rid of all of the previously seen values and keeps going until it hits an element in \n  the completed set\n  join current and completed and reset current\n  */\n\n  let current = {},\n      complete = {},\n      order = [],\n      res = [];\n  let p, s, rand_value, temp, back_ret;\n  q = [];\n  rand_value = [rand_i, rand_j];\n  s = rand_value.toString();\n  complete[s] = rand_value;\n  visited[rand_i][rand_j] = 1; // console.log(\"start \", rand_value, complete)\n\n  for (let i = 0; i < to_visit.length; i++) {\n    if (visited[to_visit[i][0]][to_visit[i][1]] != 0) {\n      // console.log(\"skip \", to_visit[i])\n      continue;\n    } else {\n      // console.log(\"to visit: \", to_visit[i])\n      q.push(to_visit[i]);\n      s = to_visit[i].toString();\n      current[s] = to_visit[i];\n      visited[to_visit[i][0]][to_visit[i][1]] = 1;\n    }\n\n    while (q.length != 0) {\n      out = q.shift();\n      x = out[0];\n      y = out[1];\n      s = out.toString(); // console.log('out: ', out)\n      // if the popped value is in the complete set, then combine the two sets\n\n      if (s in complete) {\n        order = get_maze(x, y, visited); // DEBUG\n        // for (let x = 1; x < order.length; x++) {\n        //     if (order[x-1][0] != order[x][0]){\n        //         if (order[x-1][1] != order[x][1]) {\n        //             console.log(\"order is :\", order)\n        //         }\n        //     }\n        // }\n\n        res = res.concat(order.reverse());\n        complete = { ...complete,\n          ...current\n        }; // console.log(\"completed at \", s, complete)\n\n        current = {}; // else the popped value is not in the complete set so keep searching\n      } else {\n        //TODO: disallow direction reversals\n        rand_value = random_adjacent(x, y, visited);\n        s = rand_value.toString(); // console.log(\"not in complete \", s, current, s in current)\n\n        temp = [x, y];\n\n        while (s in current) {\n          // console.log(\"starting backtrack\")\n          back_ret = backtrack(temp[0], temp[1], rand_value[0], rand_value[1], visited, current);\n          visited = back_ret.v;\n          current = back_ret.c;\n          temp = rand_value; // store this REPEATED value\n          // HAVE TO MAKE SURE RAND_VALUE IS NOT IN CURRENT AS WELL\n\n          rand_value = random_adjacent(temp[0], temp[1], visited); // get the NEW value\n\n          s = rand_value.toString();\n        } // console.log(rand_value[0], visited[temp[0]][temp[1]][0], rand_value[1], visited[temp[0]][temp[1]][1])\n        // if (rand_value[0] == visited[temp[0]][temp[1]][0] && rand_value[1] == visited[temp[0]][temp[1]][1]) {\n        //     console.log('ALERT!!!!!!!')\n        // }\n\n\n        visited[rand_value[0]][rand_value[1]] = temp; // connect the REPEATED value to the NEW value    \n\n        current[s] = rand_value;\n        q.push(rand_value);\n      }\n    }\n  }\n\n  maze.push(res[0]);\n  let temp1, temp2, temp3;\n\n  for (let i = 1; i < res.length; i++) {\n    // console.log(res[i-1], res[i])\n    temp1 = res[i - 1];\n    temp2 = res[i];\n    temp3 = 0; // walls[temp1[0]][temp1[1]] = 0\n    // walls[temp2[0]][temp2[1]] = 0\n    // the issue with the random white blip is that there can be cases where two values are on\n    // the same row but not adjacent, i.e. they are far apart\n\n    if (temp1[0] == temp2[0]) {\n      temp3 = temp1[1] + temp2[1];\n      temp3 /= 2; // console.log(temp3, temp1[1], Math.abs(temp3 - temp1[1]))\n\n      if (Math.abs(temp3 - temp[1]) != 1) {\n        continue;\n      }\n\n      maze.push([temp1[0], temp3]);\n      walls[temp1[0]][temp3] = 0; // if (Math.abs(temp1[1] - temp2[1]) != 1) {\n      //     console.log(temp1, temp2)\n      // }\n    } else if (temp1[1] == temp2[1]) {\n      temp3 = temp1[0] + temp2[0];\n      temp3 /= 2; // if (Math.abs(temp1[0] - temp2[0]) != 1) {\n      //     console.log(temp1, temp2)\n      // }\n\n      if (Math.abs(temp3 - temp1[0]) == 1) {\n        maze.push([temp3, temp1[1]]);\n        walls[temp3][temp1[1]] = 0;\n      }\n    } // } else if (Math.abs(temp1[0] - temp2[0]) + Math.abs(temp1[1] - temp2[1]) == 4) {\n    //     maze.push([temp2[0], temp1[1]])\n    //     walls[temp2[0]][temp1[1]] = 0\n    // }\n    // to see if there is any disconnect at all between vertices\n    // if (i < res.length-1 && temp1[0] != temp2[0] && temp1[1] != temp2[1] &&\n    //     temp2[0] != res[i+1][0] && temp2[1] != res[i+1][1]) {\n    //         console.log(temp1, temp2, res[i+1])\n    //     }\n\n\n    maze.push(res[i]);\n  } // console.log(set.extract())\n\n\n  let ret_walls = [];\n\n  for (let i = 0; i < walls.length; i++) {\n    for (let j = 0; j < walls[0].length; j++) {\n      if (walls[i][j] == 1) {\n        ret_walls.push([i, j]);\n      }\n    }\n  } // console.log(ret_walls)\n  // // console.log(maze)\n  // // console.log( {\"maze\": maze, \"walls\": ret_walls})\n\n\n  return {\n    \"maze\": maze,\n    \"walls\": ret_walls\n  };\n}\n\nfunction get_maze(x, y, visited) {\n  let o = [[x, y]],\n      temp;\n\n  while (visited[x][y] != 1) {\n    temp = visited[x][y]; // console.log(x, y, temp)\n\n    o.push(visited[x][y]);\n    x = temp[0];\n    y = temp[1];\n  }\n\n  return o;\n}\n\nfunction backtrack(back_start_i, back_start_j, back_end_i, back_end_j, visited, current) {\n  let out, s;\n\n  while (back_start_i != back_end_i || back_start_j != back_end_j) {\n    out = visited[back_start_i][back_start_j];\n    visited[back_start_i][back_start_j] = 0;\n    s = [back_start_i, back_start_j].toString(); // console.log(current[s])\n    // console.log(\"backtracking \", back_start_i, back_start_j, back_end_i, back_end_j, out, visited[back_end_i][back_end_j])\n\n    delete current[s];\n    back_start_i = out[0];\n    back_start_j = out[1];\n  } // console.log(\"backtracking STOP\", out, visited[back_end_i][back_end_j])\n  // console.log(visited[back_start_i][back_start_j])\n\n\n  return {\n    v: visited,\n    c: current\n  };\n}\n\nfunction random_adjacent(x, y, visited) {\n  let temp,\n      prev,\n      list = [];\n  prev = visited[x][y]; // 2 directions to travel in \n\n  if (x == 1 && y == 1 || x == global.rc - 2 && y == global.cc - 2 || x == 1 && y == global.cc - 2 || x == global.rc - 2 && y == 1) {\n    if (x == 1 && y == 1) {\n      list = [[x + 2, y], [x, y + 2]];\n    } else if (x == global.rc - 2 && y == global.cc - 2) {\n      list = [[x - 2, y], [x, y - 2]];\n    } else if (x == 1 && y == global.cc - 2) {\n      list = [[x + 2, y], [x, y - 2]];\n    } else if (x == global.rc - 2 && y == 1) {\n      list = [[x - 2, y], [x, y + 2]];\n    }\n  } else if (x == 1 || y == 1 || x == global.rc - 2 || y == global.cc - 2) {\n    // 3 directions to travel in\n    if (x == 1 || x == global.rc - 2) {\n      x == 1 ? list.push([x + 2, y]) : list.push([x - 2, y]);\n      list.push([x, y + 2]);\n      list.push([x, y - 2]);\n    } else {\n      y == 1 ? list.push([x, y + 2]) : list.push([x, y - 2]);\n      list.push([x + 2, y]);\n      list.push([x - 2, y]);\n    }\n  } else {\n    // 4 directions to travel in\n    list = [[x + 2, y], [x - 2, y], [x, y - 2], [x, y + 2]];\n  }\n\n  list = shuffle(list);\n\n  if (list[0][0] == prev[0] && list[0][1] == prev[1]) {\n    // console.log(list[0], prev, \"SAME\", list[1])\n    // console.log(prev, [x,y], list[1])\n    return list[1];\n  } else {\n    // console.log(prev, [x,y], list[0])\n    return list[0];\n  }\n  /* DEBUG\n  start  [ 9, 29 ] { '9,29': [ 9, 29 ] }\n  1 [ 15, 23 ]\n  [ 15, 23 ] [ 15, 25 ]\n  [ 15, 25 ] [ 17, 25 ]\n  [ 17, 25 ] [ 17, 27 ]\n  [ 17, 27 ] [ 15, 27 ]\n  [ 15, 27 ] [ 13, 27 ]\n  [ 13, 27 ] [ 13, 29 ]\n  backtracking  13 29 13 27 [ 13, 27 ]\n  [ 13, 29 ] [ 13, 27 ]\n  [ 13, 27 ] [ 13, 29 ]\n  [ 13, 29 ] [ 13, 31 ]\n  [ 13, 31 ] [ 11, 31 ]\n  [ 11, 31 ] [ 9, 31 ]\n  [ 9, 31 ] [ 9, 33 ]\n  [ 9, 33 ] [ 9, 35 ]\n  backtracking  9 35 9 33 [ 9, 33 ]\n  [ 9, 35 ] [ 9, 33 ]\n  [ 9, 33 ] [ 11, 33 ]\n  backtracking  11 33 9 33 [ 9, 33 ]\n  [ 11, 33 ] [ 9, 33 ]\n  [ 9, 33 ] [ 11, 33 ]\n  backtracking  11 33 11 31 [ 9, 33 ]\n  backtracking  9 33 11 31 [ 11, 33 ]\n  backtracking  11 33 11 31 0\n  */\n\n} // get random item from object\n\n\nfunction random_property(obj) {\n  var keys = Object.keys(obj);\n  return obj[keys[keys.length * Math.random() << 0]];\n}\n\n;\n\nfunction initialize_visited(row_count, col_count) {\n  var visited = new Array(row_count);\n\n  for (let i = 0; i < row_count; i++) {\n    visited[i] = new Array(col_count).fill(0);\n  }\n\n  return visited;\n}\n\nfunction shuffle(a) {\n  var j, x, i;\n\n  for (let i = a.length - 1; i > 0; i--) {\n    j = Math.floor(Math.random() * (i + 1));\n    x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n\n  return a;\n}","map":{"version":3,"sources":["/Users/Kvothe/Desktop/git/algorithms-visualizer/algorithms-visualizer/src/pathfinder/algorithms/maze_algs/wilson.js"],"names":["React","wilson","visited","initialize_visited","global","rc","cc","walls","x","y","q","out","maze","total_vertices","to_visit","i","j","push","shuffle","rand_i","Math","floor","random","rand_j","current","complete","order","res","p","s","rand_value","temp","back_ret","toString","length","shift","get_maze","concat","reverse","random_adjacent","backtrack","v","c","temp1","temp2","temp3","abs","ret_walls","o","back_start_i","back_start_j","back_end_i","back_end_j","prev","list","random_property","obj","keys","Object","row_count","col_count","Array","fill","a"],"mappings":"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","sourcesContent":["import React from 'react'\nimport '../../setup/global'\n\n// global.rc = 31\n// global.cc = 51\n// random_prims()\n/*\nChoose any vertex at random and add it to the UST.\nSelect any vertex that is not already in the UST and perform a random walk until you encounter a vertex that is in the UST.\nAdd the vertices and edges touched in the random walk to the UST.\nRepeat 2 and 3 until all vertices have been added to the UST.\n*/\n// wilson()\nexport default function wilson() {\n// function wilson () {\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n    let x, y, q, out\n    // randomize array\n    let maze = [], total_vertices = 0, to_visit = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                // need to connect all of the spaces\n                total_vertices ++;\n                to_visit.push([i,j])\n            } else {\n                walls[i][j] = 1\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n\n    to_visit = shuffle(to_visit)\n\n    let rand_i = 2 * Math.floor(Math.random() * Math.floor( (global.rc-1) /2)) + 1\n    let rand_j = 2 * Math.floor(Math.random() * Math.floor( (global.cc-1) / 2)) + 1\n    /*\n    algorithm:\n    two dictionaries: current and completed\n    if i, j in current ever sees itself, backtrack\n    backtrack algorithm gets rid of all of the previously seen values and keeps going until it hits an element in \n    the completed set\n    join current and completed and reset current\n    */\n    let current = {}, complete = {}, order = [], res= []\n    let p, s, rand_value, temp, back_ret\n    q = []\n    rand_value = [rand_i, rand_j]\n    s = rand_value.toString()\n    complete[s] = rand_value\n    visited[rand_i][rand_j] = 1\n    // console.log(\"start \", rand_value, complete)\n    for (let i = 0; i < to_visit.length; i++) {\n        if (visited[ to_visit[i][0] ][ to_visit[i][1] ] != 0) {\n            // console.log(\"skip \", to_visit[i])\n            continue\n        } else {\n            // console.log(\"to visit: \", to_visit[i])\n            q.push(to_visit[i])\n            s = to_visit[i].toString()\n            current[s]= to_visit[i]\n            visited[to_visit[i][0]][to_visit[i][1]] = 1\n        }\n        while (q.length != 0) {\n            out = q.shift()\n            x = out[0]\n            y = out[1]\n            s = out.toString()\n            // console.log('out: ', out)\n            // if the popped value is in the complete set, then combine the two sets\n            if (s in complete) {\n                order =get_maze(x,y,visited)\n                // DEBUG\n                // for (let x = 1; x < order.length; x++) {\n                //     if (order[x-1][0] != order[x][0]){\n                //         if (order[x-1][1] != order[x][1]) {\n                //             console.log(\"order is :\", order)\n                //         }\n                //     }\n                // }\n                res = res.concat(order.reverse())\n                complete = {...complete, ...current}\n                // console.log(\"completed at \", s, complete)\n                current = {}\n            // else the popped value is not in the complete set so keep searching\n            } else {\n\n                //TODO: disallow direction reversals\n                rand_value = random_adjacent(x, y, visited)\n                s = rand_value.toString()\n                // console.log(\"not in complete \", s, current, s in current)\n                temp = [x,y]\n                while (s in current) {\n                    // console.log(\"starting backtrack\")\n                    back_ret = backtrack(temp[0], temp[1], rand_value[0], rand_value[1], visited, current)\n                    visited = back_ret.v\n                    current = back_ret.c\n                    temp = rand_value // store this REPEATED value\n                    \n                    // HAVE TO MAKE SURE RAND_VALUE IS NOT IN CURRENT AS WELL\n                    rand_value = random_adjacent(temp[0], temp[1], visited) // get the NEW value\n                    s = rand_value.toString()\n                }\n                // console.log(rand_value[0], visited[temp[0]][temp[1]][0], rand_value[1], visited[temp[0]][temp[1]][1])\n                // if (rand_value[0] == visited[temp[0]][temp[1]][0] && rand_value[1] == visited[temp[0]][temp[1]][1]) {\n                //     console.log('ALERT!!!!!!!')\n                // }\n                visited[rand_value[0]][rand_value[1]] = temp // connect the REPEATED value to the NEW value    \n                current[s] = rand_value\n                q.push(rand_value)\n            }\n        }\n    }\n    maze.push(res[0])\n    let temp1,temp2, temp3\n    for (let i = 1; i < res.length; i++) {\n        // console.log(res[i-1], res[i])\n        temp1 = res[i-1]\n        temp2 = res[i]\n        temp3 = 0\n        // walls[temp1[0]][temp1[1]] = 0\n        // walls[temp2[0]][temp2[1]] = 0\n        // the issue with the random white blip is that there can be cases where two values are on\n        // the same row but not adjacent, i.e. they are far apart\n\n        if (temp1[0] == temp2[0]) {\n            temp3 = temp1[1] + temp2[1]\n            temp3 /= 2\n            // console.log(temp3, temp1[1], Math.abs(temp3 - temp1[1]))\n            if ( Math.abs(temp3 - temp[1]) != 1) {\n                continue\n            }\n            maze.push([temp1[0], temp3])\n            walls[temp1[0]][temp3] = 0\n            // if (Math.abs(temp1[1] - temp2[1]) != 1) {\n            //     console.log(temp1, temp2)\n            // }\n        } else if (temp1[1] == temp2[1]) {\n            temp3 = temp1[0] + temp2[0]\n            temp3 /= 2\n            // if (Math.abs(temp1[0] - temp2[0]) != 1) {\n            //     console.log(temp1, temp2)\n            // }\n            if (Math.abs(temp3 - temp1[0]) == 1) {\n                maze.push([temp3, temp1[1]])\n                walls[temp3][temp1[1]] = 0\n            }\n        }\n        // } else if (Math.abs(temp1[0] - temp2[0]) + Math.abs(temp1[1] - temp2[1]) == 4) {\n        //     maze.push([temp2[0], temp1[1]])\n        //     walls[temp2[0]][temp1[1]] = 0\n        // }\n        // to see if there is any disconnect at all between vertices\n        // if (i < res.length-1 && temp1[0] != temp2[0] && temp1[1] != temp2[1] &&\n        //     temp2[0] != res[i+1][0] && temp2[1] != res[i+1][1]) {\n        //         console.log(temp1, temp2, res[i+1])\n        //     }\n        maze.push(res[i])\n    }\n\n\n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n    // console.log(ret_walls)\n\n    // // console.log(maze)\n    // // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\nfunction get_maze(x, y, visited) {\n    let o = [[x,y]], temp\n    while (visited[x][y] != 1) {\n        temp = visited[x][y]\n        // console.log(x, y, temp)\n        o.push(visited[x][y])\n        x = temp[0]\n        y = temp[1]\n    }\n    return o\n}\n\nfunction backtrack(back_start_i, back_start_j, back_end_i, back_end_j, visited, current) {\n    let out, s\n    while (back_start_i != back_end_i || back_start_j != back_end_j) {\n        out = visited[back_start_i][back_start_j]\n        visited[back_start_i][back_start_j] = 0\n        s = [back_start_i, back_start_j].toString()\n        // console.log(current[s])\n        // console.log(\"backtracking \", back_start_i, back_start_j, back_end_i, back_end_j, out, visited[back_end_i][back_end_j])\n        delete current[s]\n        back_start_i = out[0]\n        back_start_j = out[1]\n    }\n    // console.log(\"backtracking STOP\", out, visited[back_end_i][back_end_j])\n    // console.log(visited[back_start_i][back_start_j])\n    return {v:visited, c:current}\n}\n\nfunction random_adjacent(x, y, visited){\n    let temp, prev, list = []\n    prev = visited[x][y]\n    // 2 directions to travel in \n    if (x == 1 && y == 1 || x==global.rc-2 && y == global.cc-2 || x == 1 && y == global.cc-2 || x== global.rc-2 && y == 1) {\n        if (x == 1 && y == 1) {\n            list = [[x+2,y], [x,y+2]]\n        } else if (x == global.rc-2 && y == global.cc-2){\n            list = [[x-2,y],[x,y-2]]\n        } else if (x == 1 && y==global.cc-2) {\n            list=[[x+2,y],[x,y-2]]\n        } else if (x==global.rc-2 && y ==1) {\n            list = [[x-2,y],[x,y+2]]\n        }\n    } else if (x == 1 || y == 1 || x == global.rc-2 || y == global.cc-2) {\n        // 3 directions to travel in\n        if (x == 1 || x == global.rc-2) {\n            x == 1? list.push([x+2,y]) : list.push([x-2,y])\n            list.push([x,y+2])\n            list.push([x,y-2])\n        } else {\n            y == 1? list.push([x,y+2]) : list.push([x,y-2])\n            list.push([x+2,y])\n            list.push([x-2,y])\n        }\n    } else {\n        // 4 directions to travel in\n        list = [[x+2,y],[x-2,y],[x,y-2],[x,y+2]]\n    }\n    list = shuffle(list)\n    if (list[0][0] == prev[0] && list[0][1] == prev[1]) {\n        // console.log(list[0], prev, \"SAME\", list[1])\n        // console.log(prev, [x,y], list[1])\n        return list[1]\n    } else {\n        // console.log(prev, [x,y], list[0])\n        return list[0]\n    }\n    /* DEBUG\n    start  [ 9, 29 ] { '9,29': [ 9, 29 ] }\n1 [ 15, 23 ]\n[ 15, 23 ] [ 15, 25 ]\n[ 15, 25 ] [ 17, 25 ]\n[ 17, 25 ] [ 17, 27 ]\n[ 17, 27 ] [ 15, 27 ]\n[ 15, 27 ] [ 13, 27 ]\n[ 13, 27 ] [ 13, 29 ]\nbacktracking  13 29 13 27 [ 13, 27 ]\n[ 13, 29 ] [ 13, 27 ]\n[ 13, 27 ] [ 13, 29 ]\n[ 13, 29 ] [ 13, 31 ]\n[ 13, 31 ] [ 11, 31 ]\n[ 11, 31 ] [ 9, 31 ]\n[ 9, 31 ] [ 9, 33 ]\n[ 9, 33 ] [ 9, 35 ]\nbacktracking  9 35 9 33 [ 9, 33 ]\n[ 9, 35 ] [ 9, 33 ]\n[ 9, 33 ] [ 11, 33 ]\nbacktracking  11 33 9 33 [ 9, 33 ]\n[ 11, 33 ] [ 9, 33 ]\n[ 9, 33 ] [ 11, 33 ]\nbacktracking  11 33 11 31 [ 9, 33 ]\nbacktracking  9 33 11 31 [ 11, 33 ]\nbacktracking  11 33 11 31 0\n    */\n\n}\n\n// get random item from object\nfunction random_property (obj) {\n    var keys = Object.keys(obj);\n    return obj[keys[ keys.length * Math.random() << 0]];\n};\n\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}"]},"metadata":{},"sourceType":"module"}