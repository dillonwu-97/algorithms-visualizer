{"version":3,"sources":["pathfinder/algorithms/path_algs/general.js","sudoku/sudoku_algorithms/lib.js","pathfinder/setup/global.js","sudoku/sudoku_algorithms/generate_sudoku.js","sudoku/sudoku_global.js","sudoku/sudoku_algorithms/backtrack_bruteforce.js","sudoku/sudoku_algorithms/backtrack_smart.js","pathfinder/setup/make_grid.js","pathfinder/setup/cell/cell.js","pathfinder/algorithms/path_algs/bfs.js","pathfinder/algorithms/path_algs/dfs.js","pathfinder/algorithms/path_algs/greedy.js","pathfinder/algorithms/path_algs/astar.js","pathfinder/algorithms/path_algs/dijkstra.js","pathfinder/algorithms/maze_algs/random_maze.js","pathfinder/algorithms/maze_algs/random_kruskal.js","pathfinder/algorithms/maze_algs/random_prims.js","pathfinder/algorithms/maze_algs/wilson.js","images/pathfinder-slow1.gif","sudoku/sudoku_grid.js","images/sudoku-slow.gif","sorting/sorting_algorithms/lib.js","sorting/sorting_algorithms/bubblesort.js","sorting/sorting_algorithms/insertionsort.js","sorting/sorting_algorithms/mergesort.js","sorting/sorting_grid.js","App.js","index.js"],"names":["backtrack","start_i","start_j","end_i","end_j","v","ret","push","a","b","initialize_visited","row_count","col_count","visited","Array","i","fill","find_next_cell","grid","j","is_valid","row","col","e","top_x","Math","floor","top_y","shuffle","x","length","random","create_table","table","debug_board","console","log","toString","global","rc","cc","si","sj","ei","ej","create_puzzle","board","coordinates","curr_val","total_solutions","test_one_solution","map","arr","slice","generate_config","keys","splice","indexOf","sectors","count","k","fill_grid","backtrack_count","values","backtrack_bruteforce","store_flag","backtrack_smart","implied_values","imply","complete_set","all_values","Set","delete","flag","possible_values","sec","add","y","filter","includes","size","next","value","walls","make_grid","props","state","start_end","handleSearch","bind","startEnd","createWall","reset","make_maze","dark_maze","type","weight","algorithm","walls_unique","from","Bfs","Dfs","greedy","astar","dijkstra","this","reset_paths","wait_time","animate_pathfind","undefined","setTimeout","animate_backtrack","path","str","document","getElementById","className","maze","event","shiftKey","id","currentTarget","parseInt","getAttribute","split","random_maze","animate_maze","maze_type","out","darken","random_kruskal","random_prims","wilson","dark_animate_maze","r","c","setState","temp","row_index","col_index","cell","create_cell","element_id","onMouseMove","onClick","class","data-toggle","alg","Component","onMouseDown","onMouseUp","bfs","q","coord","prev","return_vals","out_i","shift","out_j","dfs","pop","heapq","require","distance","cmp","manhattan","x1","x2","y1","y2","abs","min_graph","in_heap","check_adjacencies","remove_islands_edge","remove_islands","temp_i","temp_j","right_left_walls","top_down_walls","checked","o","drill","disjointSet","out_l","out_r","set","points","connected","union","ret_walls","rand_int","ret_val","in_wall_list","rand_i","rand_j","wall_list","append_adj","in_a","to_visit","s","rand_value","back_ret","temp1","temp2","temp3","current","complete","order","res","get_maze","concat","reverse","random_adjacent","back_start_i","back_start_j","back_end_i","back_end_j","list","module","exports","vis","timeid","Sudoku_grid","inner","original","solve_puzzle","visualize_puzzle","resetboard","receiveinput","customboard","before","counter","is_solvable","clearTimeout","original_grid","new_number","target","solve_type","name","generateboard","idx","unit","idy","onChange","swap","array","bubblesort","swap_values","insertionsort","ret_values","swap_value","key","merge","l","m","n1","n2","left_array","right_array","ret_seg","mergesort","left","min","MAX_HEIGHT","window","innerHeight","MAX_WIDTH","innerWidth","BAR_WIDTH","Sorting_grid","sort","newArray","index","style","height","index_i","value_i","s_i","index_j","value_j","s_j","width","Home","color","to","src","pathfinderGif","alt","sudokuGif","Pathfinder","Sudoku","Sorting","App","exact","component","ReactDOM","render"],"mappings":"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","file":"static/js/main.3e445523.chunk.js","sourcesContent":["import React from 'react';\n\n\nfunction backtrack(start_i, start_j, end_i, end_j, v) {\n\tlet ret = [[end_i, end_j]]\n\twhile(end_i != start_i || end_j != start_j) {\n\t\t// console.log(end_i ,end_j)\n\t\tret.push(v[end_i][end_j])\n\t\tlet a = end_i\n\t\tlet b = end_j\n\t\tend_i = v[a][b][0]\n\t\tend_j = v[a][b][1]\n\t}\n\treturn ret\n\t\n\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n\nexport {backtrack, initialize_visited}","import React from 'react'\n\nfunction find_next_cell(grid) {\n    for (let i = 0; i < 9; i++) {\n        for (let j =0; j < 9; j++) {\n            if (grid[i][j] == 0) {\n                return [i, j]\n            }\n        }\n    }\n    return [-1, -1]\n}\n\nfunction is_valid(grid, row, col, e) {\n    // check rows\n    for (let i = 0; i < 9; i++) {\n        if (grid[row][i] == e) {\n            return false;\n        }\n    }\n    // check columns\n    for (let i = 0; i < 9; i++) {\n        if (grid[i][col] == e) {\n            return false;\n        }\n    }\n    // check square\n    let top_x = 3 * Math.floor(row / 3) // works since 0 <= row < 9\n    let top_y = 3 * Math.floor(col / 3)\n    for (let i = top_x; i < top_x+3; i++) {\n        for (let j = top_y; j < top_y + 3; j++) {\n            if (grid[i][j] == e) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nfunction create_table() {\n\tvar table = new Array(9)\n\tfor (let i = 0; i < 9; i++) {\n\t\ttable[i] = new Array(9).fill(0)\n\t}\n    return table\n    \n}\n\nfunction debug_board(grid) {\n    for (let i = 0; i < 9; i++) {\n        console.log(grid[i].toString())\n    }\n}\n\n\nexport {find_next_cell, is_valid, shuffle, create_table, debug_board}","// This file contains the global variables that I use for the application\nglobal.rc = 31 // TODO: allow for user to input these values \nglobal.cc = 51\n\nglobal.si = 15\nglobal.sj = 20\n\nglobal.ei = 15\nglobal.ej = 30\n","// This algorithm generates the sudoku puzzles\n/*\nStart with a complete, valid board (filled with 81 numbers).\nMake a list of all 81 cell positions and shuffle it randomly.\nAs long as the list is not empty, take the next position from the list and remove the number from the related cell.\nTest uniqueness using a fast backtracking solver. My solver is - in theory - able to count all solutions, but for testing uniqueness, it will stop immediately when it finds more than one solution.\nIf the current board has still just one solution, goto step 3) and repeat.\nIf the current board has more than one solution, undo the last removal (step 3), and continue step 3 with the next position from the list\nStop when you have tested all 81 positions.\n*/\n// import React from 'react'\nimport {find_next_cell, is_valid, shuffle, create_table, debug_board} from './lib'\nimport '../sudoku_global'\n\n\n\n// console.log(generate_config())\n// let board = generate_config()\n// create_puzzle(board)\n// Generates the initial configuration for the sudoku board\n\nfunction create_puzzle(board) {\n    let coordinates = []\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9;j++) {\n            coordinates.push([i,j])\n        }\n    }\n    coordinates = shuffle(coordinates)\n    // console.log(coordinates)\n    let curr_val = 0\n    let temp_board = []\n    for (let i = 0; i < coordinates.length; i++) {\n        global.total_solutions = 0\n        curr_val = board[coordinates[i][0]][coordinates[i][1]]\n        board[coordinates[i][0]][coordinates[i][1]] = 0\n        temp_board = board.map(function(arr) {\n            return arr.slice();\n        });\n        // debug_board(temp_board)\n        let val = test_one_solution(temp_board, 0) // fill_grid parameter is 0\n        if (val == true) {\n            // console.log(\"broke the grid \")\n            board[coordinates[i][0]][coordinates[i][1]] = curr_val\n        }\n        \n        // for easy puzzle: break at 30\n        // for medium puzzle: break at 60\n        // for hard puzzle: dont break\n        \n    }\n    return board\n}\n\nfunction generate_config () {\n    let board = create_table()\n\n    // randomly get some elements\n    let a = [...Array(10).keys()]\n    a.splice(a.indexOf(0), 1)\n    \n    // fill in the diagonal boxes\n    let sectors = [0,3,3,6,6,9]\n    let count = 0\n    for (let k = 0; k < sectors.length; k+=2) {\n        count = 0\n        a = shuffle(a)\n        for (let i = sectors[k]; i < sectors[k+1]; i++) {\n            for (let j = sectors[k]; j < sectors[k+1]; j++) {\n                board[i][j] = a[count]\n                count ++\n            }\n        }\n    }\n\n    // solve the rest of the boxes\n    test_one_solution(board, 1)\n    debug_board(board)\n\n    return board\n\n}\n\n\nfunction test_one_solution(grid, fill_grid) {\n    // function backtrack_bruteforce(grid) {\n    let i, j, ret\n    ret = find_next_cell(grid)\n    i = ret[0]\n    j = ret[1]\n    if (i == -1) {\n        global.total_solutions ++\n        // console.group(global.total_solutions)\n        // if we are JUST filling the grid, return true once we hit the end\n        if (fill_grid == 1) { return true }\n        // otherwise check if there is a second solution; if there is no second solution, return false\n        // if there is a second solution, return true\n        if (global.total_solutions >= 2) {\n            return true\n        } else {\n            return false\n        }\n    }\n    for (let e= 1; e < 10; e++) {\n        if (is_valid(grid, i, j, e) ) {\n            grid[i][j] = e\n            // console.log(i,j,e)\n            if (test_one_solution(grid, fill_grid)) {\n                return true\n            } \n            grid[i][j] = 0\n            // console.log(i,j,e)\n            global.backtrack_count ++;\n        }\n    }\n    return false\n}   \n\nexport {generate_config, create_puzzle}","// global variables used for sudoku solver\nglobal.backtrack_count = 0\nglobal.values = []\nglobal.total_solutions = 0","import React from 'react'\nimport {find_next_cell, is_valid} from './lib'\nimport '../sudoku_global'\n\n/******************* Testing function ********************/\n// test = [[0,0,5,3,0,0,0,0,0],\n// [8,0,0,0,0,0,0,2,0],\n// [0,7,0,0,1,0,5,0,0],\n// [4,0,0,0,0,5,3,0,0],\n// [0,1,0,0,7,0,0,0,6],\n// [0,0,3,2,0,0,0,8,0],\n// [0,6,0,5,0,0,0,0,9],\n// [0,0,4,0,0,0,0,3,0],\n// [0,0,0,0,0,9,7,0,0]]\n\n// val = backtrack_bruteforce(test, 0, 0)\n// for (let i = 0; i < 9; i++) {\n//     console.log(test[i].toString())\n// }\n// console.log(global.backtrack_count, val)\n\nexport default function backtrack_bruteforce(grid, store_flag) {\n// function backtrack_bruteforce(grid) {\n    let i, j, ret\n    ret = find_next_cell(grid)\n    i = ret[0]\n    j = ret[1]\n    if (i == -1) {\n        return true\n    }\n    for (let e= 1; e < 10; e++) {\n        if (is_valid(grid, i, j, e) ) {\n            grid[i][j] = e\n            // console.log(i,j,e)\n            if (store_flag == 1) {\n                global.values.push([i,j,e])\n            }\n            if (backtrack_bruteforce(grid, store_flag)) {\n                return true\n            } \n            grid[i][j] = 0\n            // console.log(i,j,e)\n            if (store_flag == 1) {\n                global.values.push([i,j,0, 1])\n            }\n            global.backtrack_count ++;\n        }\n    }\n    return false\n}   \n\n\n/*\n[[ 5,3,0,0,7,0,0,0,0 ],  \n[ 6,0,0,1,9,5,0,0,0 ],  \n[ 0,9,8,0,0,0,0,6,0],  \n[ 8,0,0,0,6,0,0,0,3],  \n[ 4,0,0,8,0,3,0,0,1 ],  \n[ 7,0,0,0,2,0,0,0,6 ],  \n[ 0,6,0,0,0,0,2,8,0 ],  \n[ 0,0,0,4,1,9,0,0,5 ],  \n[ 0,0,0,0,8,0,0,7,9]]\n*/","import React from 'react'\nimport {find_next_cell, is_valid} from './lib'\nimport '../sudoku_global'\n\n/******************* Testing function ********************/\n// test = [[8,5,0,0,0,2,4,0,0],\n// [7,2,0,0,0,0,0,0,9],\n// [0,0,4,0,0,0,0,0,0],\n// [0,0,0,1,0,7,0,0,2],\n// [3,0,5,0,0,0,9,0,0],\n// [0,4,0,0,0,0,0,0,0],\n// [0,0,0,0,8,0,0,7,0],\n// [0,1,7,0,0,0,0,0,0],\n// [0,0,0,0,3,6,0,4,0]]\n\n// global.backtrack_count = 0\n// global.values = []\n\n// val = backtrack_smart(test, 0, 0)\n// for (let i = 0; i < 9; i++) {\n//     console.log(test[i].toString())\n// }\n// console.log(global.values)\n// console.log(global.backtrack_count, val)\n\n\n// imply(test, 0, 0, 1)\n/******************* Methods ********************/\n// \"1\" in global.values[3] stands for whether to add a backtrack counter or not\nexport default function backtrack_smart(grid, store_flag) {\n    // function backtrack_smart(grid) {\n    let i , j, ret, implied_values\n    ret = find_next_cell(grid)\n    // console.log('DEBUG')\n    // for (let i = 0; i < 9; i++) {\n    //     console.log(grid[i].toString())\n    // }\n    // console.log(\"next cell is \", ret)\n    i = ret[0]\n    j = ret[1]\n    if (i == -1) {\n        return true\n    }\n    for (let e= 1; e < 10; e++) {\n        if (is_valid(grid, i, j, e) ) {\n            grid[i][j] = e\n            implied_values = imply(grid, i, j, e)\n            if (store_flag == 1) {\n                global.values.push([i,j,e])\n                global.values = [...global.values,...implied_values]\n            }\n            // global.values = [...global.values, ...implied_values]\n            if (backtrack_smart(grid, store_flag)) {\n                return true\n            }\n            // undoing the implied values\n            grid[i][j] = 0\n            for (let x = 0; x < implied_values.length; x++) {\n                grid[implied_values[x][0]][implied_values[x][1]] = 0\n                if (store_flag == 1) {\n                    global.values.push([implied_values[x][0], implied_values[x][1], 0])\n                }\n            }\n            if (store_flag == 1) {\n                global.values.push([i,j,0,1])\n            }\n            global.backtrack_count ++;\n        }\n    }\n    return false\n}   \n\n// separate into 9 regions\n// can also take the sum of each set and subtract from current so that if current has only 1 value, then that means it must be that value\n// (row_start, row_end, col_start, col_end)\nfunction imply(grid, i, j, e) {\n    let sectors= [[0,3,0,3],[3,6,0,3],[6,9,0,3],[0,3,3,6],[3,6,3,6],[6,9,3,6],[0,3,6,9],[3,6,6,9],[6,9,6,9]]\n    let implied_values = []\n    grid[i][j] = e\n    let complete_set, v\n    let all_values = new Set([...Array(10).keys()])\n    all_values.delete(0)\n    let flag = 1\n    while (flag == 1) {\n        flag = 0\n        let possible_values = [...Array(9)].map(i=>Array(9).fill(0))\n        for (let sec = 0; sec < sectors.length; sec++) {\n            for (let i = sectors[sec][0]; i < sectors[sec][1]; i++) {\n                for (let j = sectors[sec][2]; j < sectors[sec][3]; j++) {\n                    if (grid[i][j] == 0) {\n                        complete_set = new Set();\n                        // adding values for rows and columns\n                        for (let x = 0; x < 9; x++) {  \n                            // add the values it CAN NOT be             \n                            if (grid[i][x] != 0) {complete_set.add(grid[i][x])}\n                            if (grid[x][j] != 0) {complete_set.add(grid[x][j])}\n                        }\n                        // adding the values for the respective box\n                        // add the values it CAN NOT be             \n                        for (let x = sectors[sec][0]; x < sectors[sec][1]; x++) {\n                            for (let y = sectors[sec][2]; y < sectors[sec][3]; y++) {\n                                if (grid[x][y] != 0) {complete_set.add(grid[x][y])}\n                            }\n                        }\n                        possible_values[i][j] = [...complete_set] // possible_values[i][j] contains values it cannot be\n                        // possible_values[i][j] contains values it can be\n                        possible_values[i][j] = new Set([...all_values].filter(x => !possible_values[i][j].includes(x) ));\n                        if (possible_values[i][j].size == 1) {\n                            v = possible_values[i][j].values().next().value\n                            if (is_valid(grid, i, j, v)) {\n                                // console.log(\"found one\", v)\n                                implied_values.push([i, j, v])\n                                grid[i][j] = v\n                                flag = 1\n                            }\n                        }\n                    }       \n                }\n            }\n        }\n    }\n    return implied_values\n    // return {\"iv\": implied_values, \"g\": grid}\n}","\nimport React, {Component} from 'react';\nimport Cell from './cell/cell'\nimport Bfs from '../algorithms/path_algs/bfs'\nimport Dfs from '../algorithms/path_algs/dfs'\nimport greedy from '../algorithms/path_algs/greedy'\nimport astar from '../algorithms/path_algs/astar'\nimport dijkstra from '../algorithms/path_algs/dijkstra'\nimport random_maze from '../algorithms/maze_algs/random_maze'\nimport random_kruskal from '../algorithms/maze_algs/random_kruskal'\nimport random_prims from '../algorithms/maze_algs/random_prims'\nimport wilson from '../algorithms/maze_algs/wilson'\nimport './global'\n\n/****************************** CSS imports ******************************/\nimport { Dropdown, DropdownButton } from 'react-bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport 'jquery/dist/jquery.min.js';\nimport 'bootstrap/dist/js/bootstrap.min.js';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './cell/cell.css'\nimport './make_grid.css'\n\n\n\nconst row_count = global.rc // TODO: allow for user to input these values\nconst col_count = global.cc\n\nlet start_i = 15\nlet start_j = 20\n\nlet end_i = 15\nlet end_j = 30\n\n// for now, create walls that are hard coded and then color them in\nlet walls = []\n\n\nexport default class make_grid extends Component {\n\t\n\tconstructor(props) {\n\t\tsuper()\n\t\tthis.state = {\n\t\t\tstart_end: 0 // keeps track of start (0) or end (1)\n\t\t}\n\t\tthis.handleSearch = this.handleSearch.bind(this)\n\t\tthis.startEnd = this.startEnd.bind(this)\n\t\tthis.createWall = this.createWall.bind(this)\n\t\tthis.reset = this.reset.bind(this)\n\t\tthis.make_maze = this.make_maze.bind(this)\n\t\tthis.dark_maze = this.dark_maze.bind(this)\n\t}\n\n\t/************************** General Use Methods **************************/\n\t// create a cell\n\tcreate_cell () {\n\t\tconst cell = {\n\t\t\ttype: \"\",\n\t\t\tweight: 1\n\t\t}\n\t\treturn cell\n\t}\n\n\t/************************* Pathfinding Methods *************************/\n\t// runs bfs and returns the nodes visited path and backtrack path\n\n\thandleSearch(start_i, start_j, end_i, end_j, walls, algorithm) {\n\t\tfor (let i = 0; i < walls.length; i++) {\n\t\t\twalls[i] = walls[i].toString()\n\t\t}\n\t\tlet walls_unique = Array.from(new Set(walls));\n\t\t// run bfs\n\t\tlet ret;\n\t\tswitch (algorithm) {\n\t\t\tcase \"bfs\":\n\t\t\t\t// console.log(start_i, \" \", start_j)\n\t\t\t\tret = Bfs(start_i, start_j, end_i, end_j, walls_unique)\n\t\t\t\tbreak\n\t\t\tcase \"dfs\":\n\t\t\t\t// console.log(\"dfs switch case\")\n\t\t\t\tret = Dfs(start_i, start_j, end_i, end_j, walls_unique)\n\t\t\t\tbreak\n\t\t\tcase \"greedy\":\n\t\t\t\t// console.log(\"greedy\")\n\t\t\t\tret = greedy(start_i, start_j, end_i, end_j, walls_unique)\n\t\t\t\tbreak\n\t\t\tcase \"astar\":\n\t\t\t\tret = astar(start_i, start_j, end_i, end_j, walls_unique)\n\t\t\t\tbreak\n\t\t\tcase \"dijkstra\":\n\t\t\t\tret = dijkstra(start_i, start_j, end_i, end_j, walls_unique)\n\t\t\t\tbreak\n\n\t\t}\n\t\tthis.reset_paths()\n\t\tlet wait_time = this.animate_pathfind(ret)\n\t\t// console.log(wait_time)\n\t\tif (ret[ret.length-1][0][0] != undefined) {\n\t\t\t// console.log(algorithm, \" \", ret[ret.length-1].length)\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.animate_backtrack(ret[ ret.length - 1])\n\t\t\t}, wait_time)\n\t\t}\n\t}\n\n\t/************************* Animation Methods *************************/\n\t// pathfinding animation\n\tanimate_pathfind(path) {\n\t\t// length is path - 1 because the last element of the input is the array for backtrack steps\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tlet x = path[i][0]\n\t\t\tlet y = path[i][1]\n\t\t\tconst str = 'cell-' + x + '-' + y\n\t\t\tif (document.getElementById(str).className == 'cell cell-start') {\n\t\t\t// if (x == start_i && y == start_j) {\n\t\t\t\t// document.getElementById(str).className = 'cell cell-start'\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (document.getElementById(str).className == 'cell cell-finish') {\n\t\t\t// if (x == end_i && y == end_j) {\n\t\t\t\t// document.getElementById(str).className = 'cell cell-finish'\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t// if (x == 15 && y == 20 || x == 15 && y==30) {\n\t\t\t// \tconsole.log(\"debugging \", document.getElementById(str).className)\n\t\t\t// }\n\t\t\t// if (document.getElementById(str).className== 'cell ') {\n\t\t\t\t// for some reason, having a console.log makes the color change, but not having this doesnt\n\t\t\t\t// if (x == 15 && y == 20 || x == 15 && y==30) {\n\t\t\t\t// \tconsole.log(\"debugging \", document.getElementById(str).className, \" \", x, \" \", y)\n\t\t\t\t// }\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(str).className = 'cell cell-visited'\n\t\t\t\t// this.animate_backtrack(path[ path.length - 1])\n\t\t\t},10 * i)\n\t\t\t// }\n\t\t}\n\t\treturn 10 * path.length\n\n\t}\n\n\t// backtrack animation\n\tanimate_backtrack(path) {\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tlet x = path[i][0]\n\t\t\tlet y = path[i][1]\n\t\t\tif (x == start_i && y == start_j) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (x == end_i && y == end_j) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// console.log(x, y)\n\t\t\tconst str = 'cell-' + x + '-' + y\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(str).className = 'cell cell-backtrack'\n\t\t\t},50 * i);\n\t\t}\n\t}\n\n\tanimate_maze() {\n\t\tfor (let i = 0; i < walls.length; i++) {\n\t\t\tconst str = 'cell-' + walls[i][0] + '-' + walls[i][1]\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(str).className = 'cell cell-wall'\n\t\t\t},5 * i);\n\t\t}\n\t}\n\n\tdark_animate_maze(maze) {\n\t\tfor (let i = 0; i < maze.length; i++) {\n\t\t\tconst str = 'cell-' + maze[i][0] + '-' + maze[i][1]\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(str).className = 'cell '\n\t\t\t},5 * i);\n\t\t}\n\t}\n\n\t/****************************** Generate Walls *************************/\n\n\tcreateWall(event) {\n\t\tif (event.shiftKey) {\n\t\t\tconst {id} = event.currentTarget // row and col are not returned for this\n\t\t\tlet r = parseInt(document.getElementById(id).getAttribute(\"row\"))\n\t\t\tlet c = parseInt(document.getElementById(id).getAttribute(\"col\"))\n\t\t\tdocument.getElementById(id).className = 'cell cell-wall'\n\t\t\tlet a = id.split(\"-\")[1]\n\t\t\tlet b = id.split(\"-\")[2]\n\t\t\t// console.log(a,b)\n\t\t\twalls.push([a,b])\n\t\t} \n\t}\n\n\tasync make_maze() {\n\t\tawait this.reset()\n\t\twalls = random_maze()\n\t\tthis.animate_maze()\n\t}\n\n\tdark_maze(maze_type) {\n\t\tlet out;\n\t\tthis.darken()\n\t\tswitch(maze_type) {\n\t\t\tcase \"kruskal\":\n\t\t\t\tout = random_kruskal()\n\t\t\t\tbreak\n\t\t\tcase \"prim\":\n\t\t\t\tout = random_prims()\n\t\t\t\tbreak\n\t\t\tcase \"wilson\":\n\t\t\t\tout = wilson()\n\t\t\t\tbreak\n\t\t}\n\t\twalls = out.walls\n\t\tthis.dark_animate_maze(out.maze)\n\t}\n\n\n\t/****************************** Mouse Click Methods *************************/\n\tstartEnd(event) {\n\t\t// TODO;\n\t\t// disallow clicking of walls\n\t\tconst {id} = event.currentTarget // row and col are not returned for this\n\t\tlet r = parseInt(document.getElementById(id).getAttribute(\"row\"))\n\t\tlet c = parseInt(document.getElementById(id).getAttribute(\"col\"))\n\t\tif (this.state.start_end == 0) {\n\t\t\t// reset the start colors\n\t\t\tdocument.getElementById('cell-' + start_i + '-' + start_j).className = 'cell '\n\t\t\tdocument.getElementById(id).className = 'cell cell-start'\n\t\t\tthis.setState({\n\t\t\t\tstart_end: 1\n\t\t\t})\n\t\t\tstart_i = r\n\t\t\tstart_j = c\n\t\t} else {\n\t\t\tdocument.getElementById('cell-' + end_i + '-' + end_j).className = 'cell '\n\t\t\tdocument.getElementById(id).className = 'cell cell-finish'\n\t\t\tthis.setState({\n\t\t\t\tstart_end: 0\n\t\t\t})\n\t\t\tend_i = r\n\t\t\tend_j = c\n\t\t}\n\t\t\n\t}\n\n\t// darkens the entire grid\n\tdarken() {\n\t\tfor (let i = 0; i < row_count; i++) {\n\t\t\tfor (let j = 0; j < col_count; j++) {\n\t\t\t\tlet id = 'cell-' + i + '-' + j;\n\t\t\t\tdocument.getElementById(id).className = 'cell cell-wall'\n\t\t\t}\n\t\t}\n\t}\n\n\t// clears the entire grid\n\treset() {\n\t\tfor (let i = 0; i < row_count; i++) {\n\t\t\tfor (let j = 0; j < col_count; j++) {\n\t\t\t\tlet id = 'cell-' + i + '-' + j;\n\t\t\t\tdocument.getElementById(id).className = 'cell '\n\t\t\t}\n\t\t}\n\t\twalls = []\n\t}\n\n\t// keeps the walls; resets the path colors\n\treset_paths() {\n\t\tfor (let i = 0; i < row_count; i++) {\n\t\t\tfor (let j = 0; j < col_count; j++) {\n\t\t\t\tlet id = 'cell-' + i + '-' + j;\n\t\t\t\tif (document.getElementById(id).className == 'cell cell-visited' || \n\t\t\t\tdocument.getElementById(id).className == 'cell cell-backtrack') {\n\t\t\t\t\tdocument.getElementById(id).className = 'cell '\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/****************************** Rendering *************************/\n\trender() {\n\t\t// setup for grid\n\t\tlet grid = []\n\t\tfor (let i = 0; i < row_count; i++) {\n\t\t\tlet temp = []\n\t\t\tfor (let j = 0; j < col_count; j++) {\n\t\t\t\ttemp.push(0)\n\t\t\t}\n\t\t\tgrid.push(temp)\n\t\t}\n\t\tlet maze_list = [\"kruskal\", \"prim\", \"wilson\"]\n\t\tlet alg_list = [\"bfs\", \"dfs\", \"greedy\", \"astar\", \"dijkstra\"]\n\t\treturn (\n\t\t\t<div className=\"parent\">\n\t\t\t\t<div className = \"grid\" > \n\t\t\t\t\t<div className= \"wrapper\">\n\t\t\t\t\t\t{grid.map((row, row_index) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<div className=\"row\">\n\t\t\t\t\t\t\t\t{row.map((col, col_index) => {\n\t\t\t\t\t\t\t\t\tconst cell = this.create_cell()\n\t\t\t\t\t\t\t\t\tlet {type, weight} = cell\n\t\t\t\t\t\t\t\t\tif (row_index == start_i && col_index == start_j) {\n\t\t\t\t\t\t\t\t\t\ttype = 'cell-start'\n\t\t\t\t\t\t\t\t\t} else if (row_index == end_i && col_index == end_j) {\n\t\t\t\t\t\t\t\t\t\ttype = 'cell-finish'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn (<Cell element_id={'cell-' + row_index + '-' + col_index}\n\t\t\t\t\t\t\t\t\ttype = {type} weight = {weight} row = {row_index} col = {col_index} \n\t\t\t\t\t\t\t\t\tonMouseMove={this.createWall} \n\t\t\t\t\t\t\t\t\tonClick={this.startEnd} />)\n\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t   \n\t\t\t\t</div>\n\t\t\t\t<div class=\"container\">\n\t\t\t\t\t<div id=\"pathfinder-dropdown\" class=\"row text-center\">\n\t\t\t\t\t\t<div class=\"col-4\">\n\t\t\t\t\t\t\t<div class=\"dropdown\" >\n\t\t\t\t\t\t\t\t<button class=\"btn btn-secondary dropdown-toggle\" className=\"algorithms-button\" type=\"button\" data-toggle=\"dropdown\">\n\t\t\t\t\t\t\t\t\tSelect Algorithm\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<div class=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t{alg_list.map((alg) => {\n\t\t\t\t\t\t\t\t\t// console.log(typeof(alg))\n\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t<a class=\"dropdown-item\" className=\"algorithms-menu\" onClick = {()=>this.handleSearch(\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart_i,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstart_j,\n\t\t\t\t\t\t\t\t\t\t\t\t\tend_i,\n\t\t\t\t\t\t\t\t\t\t\t\t\tend_j,\n\t\t\t\t\t\t\t\t\t\t\t\t\twalls,\n\t\t\t\t\t\t\t\t\t\t\t\t\talg)}>\n\t\t\t\t\t\t\t\t\t\t\t\t\tVisualize {alg}\n\t\t\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"col-4\">\n\t\t\t\t\t\t\t<button type=\"button\" class=\"btn btn-outline-secondary\" className=\"btn-xlarge\" id=\"reset button\"\n\t\t\t\t\t\t\tonClick={()=>this.reset()}>\n\t\t\t\t\t\t\t\tReset\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"col-4\">\n\t\t\t\t\t\t\t<div class=\"dropdown\" >\n\t\t\t\t\t\t\t\t\t<button class=\"btn btn-secondary dropdown-toggle\" className=\"maze-button\" type=\"button\" data-toggle=\"dropdown\">\n\t\t\t\t\t\t\t\t\t\tSelect Maze\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t<div class=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t<a class=\"dropdown-item\" className=\"maze-menu\" onClick = {this.make_maze}>\n\t\t\t\t\t\t\t\t\t\t\t\tGeneral Maze\n\t\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{maze_list.map((maze) => {\n\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<a class=\"dropdown-item\" className=\"maze-menu\" onClick = {()=>this.dark_maze(maze)}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{maze} maze\n\t\t\t\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t)\n\t}\n}","import React, {Component} from 'react';\n\nimport './cell.css'\n\nexport default class cell extends Component { \n\n\trender() {\n\t\tconst {element_id, type, weight, row, col, onClick, onMouseDown, onMouseUp,\n\t\t\tonMouseMove} = this.props\n\t\treturn (\n\t\t\t<div id={element_id} \n\t\t\trow = {row} \n\t\t\tcol = {col}\n\t\t\tclassName= {'cell ' + type} \n\t\t\tonClick = {onClick}\n\t\t\tonMouseMove= {onMouseMove}\n\t\t\t>\n\t\t\t</div>\n\t\t)\n\t}\n}","import React from 'react';\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\n\n\n// TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n\n\n// takes in some start and end location\n// takes in the row and column size of the grid\nexport default function bfs(start_i, start_j, end_i, end_j, walls) {\n\tlet q = [] // using push and shift\n\tlet row_count = global.rc\n\tlet col_count = global.cc\n\t// visited, all are initialized to null \n\t// console.log(start_i, start_j, end_i, end_j, row_count)\n\tlet visited = initialize_visited(row_count, col_count);\n\tq.push({coord: [start_i, start_j], count: 0, prev: [start_i, start_j]})\n\tlet out; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n\t\tout = q.shift()\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n\t\t// appending in each direction\n\t\tvisited[out_i][out_j] = out.prev\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\tconsole.log('bfs count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i-1, out_j], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j-1], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i+1, out_j], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j+1], count: out.count+1, prev:out.coord})\n\t\t\tvisited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n","import React from 'react';\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\n\n// TODO: Improve so that it has wall detection\n// TODO: Improve so that it can detect errors\n\n\n// takes in some start and end location\n// takes in the row and column size of the grid\nexport default function dfs(start_i, start_j, end_i, end_j, walls) {\n\tlet q = [] // using push and shift\n\tlet row_count = global.rc\n\tlet col_count = global.cc\n\t// visited, all are initialized to null \n\t// console.log(start_i, start_j, end_i, end_j, row_count)\n\tlet visited = initialize_visited(row_count, col_count);\n\tq.push({coord: [start_i, start_j], count: 0, prev: [start_i, start_j]})\n\tlet out; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n\t\tout = q.pop()\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (visited[out_i][out_j] != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n\t\t// appending in each direction\n\t\tvisited[out_i][out_j] = out.prev\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log('ended')\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out_i, out_j, out_i, out_j+1, out_i-1, out_j, out_i, out_j-1, out_i+1,)\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i+1, out_j], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j-1], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n\t\t\tq.push({coord:[out_i-1, out_j], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n\t\t\tq.push({coord:[out_i, out_j+1], count: out.count+1, prev:out.coord})\n\t\t\t// visited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n","import React from 'react'\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\nvar heapq = require('heapq')\n\n\nexport default function greedy(start_i, start_j, end_i, end_j, walls) {\n\n    var cmp = function(x, y) {return x[0] < y[0];}\n\n    let row_count = global.rc\n    let col_count = global.cc\n\n\tlet q = [] // using push and shift\n\t// visited, all are initialized to null \n    // console.log(start_i, start_j, end_i, end_j, row_count)\n    // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n\tlet visited = initialize_visited(row_count, col_count);\n\theapq.push(q, [0, {coord: [start_i, start_j], count: 0, prev: [start_i, start_j]}], cmp )\n\tlet out_pre, out, distance; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n        out_pre = heapq.pop(q, cmp)\n        out = out_pre[1]\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n\t\t// appending in each direction\n\t\tvisited[out_i][out_j] = out.prev\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log('greedy count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n            distance = (manhattan(end_i, out_i-1, end_j, out_j)) // 10 for uniform cost\n\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n            distance = (manhattan(end_i, out_i, end_j, out_j-1))\n            heapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n            distance = (manhattan(end_i, out_i+1, end_j, out_j))\n\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n            distance = (manhattan(end_i, out_i, end_j, out_j+1))\n\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n\nfunction manhattan(x1, x2, y1, y2) {\n    return Math.abs(x1-x2) + Math.abs(y1-y2)\n}","import React from 'react'\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\nvar heapq = require('heapq')\n\n\nexport default function astar(start_i, start_j, end_i, end_j, walls) {\n\n    var cmp = function(x, y) {\n\t\t// console.log(x[0], y[0])\n\t\treturn x[0] < y[0];\n\t}\n\n    let row_count = global.rc\n    let col_count = global.cc\n\n\tlet q = [] // using push and shift\n\t// visited, all are initialized to null \n    // console.log(start_i, start_j, end_i, end_j, row_count)\n    // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n    let visited = initialize_visited(row_count, col_count);\n\tlet min_graph = initialize_visited(row_count, col_count)\n\tlet in_heap = initialize_visited(row_count, col_count);\n\theapq.push(q, [0, {coord: [start_i, start_j], count: 0, prev: [start_i, start_j]}], cmp )\n\tlet out_pre, out, distance; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\n\t// TODO: the issue is that nodes that are being visited from suboptimal squares. as a result, we are not going from the best square\n\twhile(q.length != 0) {\n\t\tout_pre = heapq.pop(q, cmp)\n\t\t// console.log(\"distance \", out_pre[0])\n        out = out_pre[1]\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\tin_heap[out_i][out_j] --;\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn_vals.push([out_i, out_j])\n        // appending in each direction\n        if (visited[out_i][out_j] == 1 || min_graph[out_i][out_j] > out.count) {\n            min_graph[out_i][out_j] = out.count\n            visited[out_i][out_j] = out.prev\n        }\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log(min_graph)\n\t\t\tconsole.log('astar count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i-1, end_j, out_j)) \n\t\t\tif(visited[out_i-1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t} else if (distance < in_heap [out_i-1][out_j] ){\n\t\t\t\tin_heap [out_i-1][out_j] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j > 0){\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j-1))\n\t\t\tif (visited[out_i][out_j-1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j-1] = 1\n\t\t\t\tin_heap [out_i][out_j-1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j-1]) {\n\t\t\t\tin_heap [out_i][out_j-1] = distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_i < row_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i+1, end_j, out_j))\n\t\t\tif (visited[out_i+1][out_j] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i+1][out_j] = 1\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t} else if (distance < in_heap [out_i+1][out_j]) {\n\t\t\t\tin_heap [out_i+1][out_j]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t\tif (out_j < col_count-1) {\n\t\t\tdistance = out.count + (manhattan(end_i, out_i, end_j, out_j+1))\n\t\t\tif (visited[out_i][out_j+1] == 0) {\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t\tvisited [out_i][out_j+1] = 1\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t} else if (distance < in_heap [out_i][out_j+1]) {\n\t\t\t\tin_heap [out_i][out_j+1]=distance;\n\t\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n\nfunction manhattan(x1, x2, y1, y2) {\n    return Math.abs(x1-x2) + Math.abs(y1-y2)\n}","import React from 'react'\nimport { backtrack, initialize_visited } from './general'\nimport '../../setup/global'\nvar heapq = require('heapq')\n\n\nexport default function dijkstra(start_i, start_j, end_i, end_j, walls) {\n    console.log(start_i, start_j)\n    var cmp = function(x, y) {return x[0] < y[0];}\n\n    let row_count = global.rc\n    let col_count = global.cc\n    let weight = 1 // this can change later\n\n\tlet q = [] // using push and shift\n\t// visited, all are initialized to null \n    // console.log(start_i, start_j, end_i, end_j, row_count)\n    // heapq.push(heap, [-3, {a:1, b:2}], cmp);\n\n    let visited = initialize_visited(row_count, col_count);\n\theapq.push(q, [0, {coord: [start_i, start_j], count: 0, prev: [start_i, start_j]}], cmp )\n\tlet out_pre, out, distance; \n\tlet return_vals = []; // return the list of nodes that were visited in order\n\twhile(q.length != 0) {\n        out_pre = heapq.pop(q, cmp)\n        out = out_pre[1]\n\t\tlet out_i = out.coord[0]\n\t\tlet out_j = out.coord[1]\n\t\t// console.log(walls)\n\t\t// console.log(typeof([13,25]), typeof(walls[0]))\n\t\tif (walls.includes([out_i, out_j].toString())) {\n\t\t\tcontinue;\n\t\t}\n        return_vals.push([out_i, out_j])\n        visited[out_i][out_j] = out.prev\n        // appending in each direction\n\n\t\tif (out_i == end_i && out_j == end_j) {\n\t\t\t// console.log('astar count: ', out.count)\n\t\t\treturn_vals.push(backtrack(start_i, start_j, end_i, end_j, visited))\n\t\t\tbreak;\n\t\t}\n\t\t// console.log(out)\n\t\tif (out_i > 0 && visited[out_i-1][out_j] == 0) {\n            distance = out.count + weight // 10 for uniform cost\n\t\t\theapq.push(q, [distance, {coord:[out_i-1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i-1][out_j] = 1 // to mark the node as in the process of being visited\n\t\t}\n\t\tif (out_j > 0 && visited[out_i][out_j-1] == 0) {\n            distance = out.count + weight\n            heapq.push(q, [distance, {coord:[out_i, out_j-1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i][out_j-1] = 1\n\t\t}\n\t\tif (out_i < row_count-1 && visited[out_i+1][out_j] == 0) {\n            distance = out.count + weight\n\t\t\theapq.push(q, [distance, {coord:[out_i+1, out_j], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i+1][out_j] = 1\n\t\t}\n\t\tif (out_j < col_count-1 && visited[out_i][out_j+1] == 0) {\n            distance = out.count + weight\n\t\t\theapq.push(q, [distance, {coord:[out_i, out_j+1], count: out.count+1, prev:out.coord}], cmp)\n\t\t\tvisited [out_i][out_j+1] = 1\n\t\t}\n\t}\n\treturn return_vals // return_vals[-1] is the backtrack array; everything before that is order of traversal\n\n\n}\n","import React from 'react'\nimport '../../setup/global'\n \nexport default function random_maze() {\n    // create setup to check adjacencies\n    let visited = initialize_visited(global.rc, global.cc);\n    let maze = []\n    // build the maze\n    // can transform shape of map by changing value for this\n    for (let i = 0; i < global.rc; i++) {\n        for (let j = 0; j < global.cc; j++) {\n            if (Math.random() > .15) {\n                if (check_adjacencies(i, j, visited)) {\n                    visited[i][j] = 1\n                }\n                // visited[i][j]=1\n            }\n        }\n    }\n\n    // make sure there are no islands\n\n    for (let i = 0; i < global.cc; i++) {\n        maze.push([0,i])\n        maze.push([global.rc-1,i])\n        visited[0][i] = 1\n        visited[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        maze.push([i, 0])\n        maze.push([i, global.cc-1])\n        visited[i][0] = 1\n        visited[i][global.cc-1] = 1\n    }\n\n    // this is not changing\n    for (let i = 0; i < 2; i++) {\n        visited = remove_islands(visited)\n        visited = remove_islands_edge(visited)\n        // console.log(visited)\n    }\n    // for some reason, there is always something blocked on the last row so i'm just going to get rid of it\n    for (let i = 1; i < global.cc-1; i++) {\n        if (Math.random() > .15) {\n            visited[global.rc-2][i] = 0\n        }\n            // visited[global.rc-2][i] = 0\n    }\n    visited = remove_islands_edge(visited)\n\n    // remove islands using second idea: tracing the walls to see if they touch\n\n    \n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if(visited[i][j] == 1) {\n                maze.push([i,j])\n            }\n        }\n    }\n    \n    return maze\n}\n\n// new strategy: \n// go along each edge of the graph and if you ever hit an edge, then create an opening?\nfunction remove_islands_edge (visited) {\n    let q = []\n    let out, out_i, out_j, temp_i, temp_j, x, y;\n    let right_left_walls = [1, global.cc-2]\n    let top_down_walls = [1, global.rc-2]\n\n    // for \n    let checked = initialize_visited(global.rc, global.cc)\n    for (let j = 1; j > -1; j--) {        \n        for (let i = 1; i < global.cc-1; i++) {\n            // console.log(\"i is: \", i)\n            if (visited[top_down_walls[j]][i] == 1 && checked[top_down_walls[j]][i] == 0) {\n                q.push([top_down_walls[j],i])\n                while (q.length != 0) {\n                    out = q.shift()\n                    out_i = out[0]\n                    out_j = out[1]\n                    // console.log(out_i, out_j, checked[out_i][out_j])\n                    // condition: cannot be adjacent to each other\n                    // wall detection mechanism\n                    if (out_j in right_left_walls || out_i in top_down_walls) {\n                        if (Math.abs(i - out_j) > 0 || Math.abs(top_down_walls[j] -out_i) > 0) {\n                            // console.log(\"breakpoint \", out_i, out_j)\n                            \n                            x = out_i\n                            y = out_j\n                            // console.log (\"wtf \", y)\n                            while (y > 0 && visited[x][y] == 1) {\n                                visited[x][y] = 0\n                                y-=1\n                            }\n                            while (x > 0 && visited[x][out_j] == 1) {\n                                visited[x][out_j] = 0\n                                x-=1\n                            }\n                            x = out_i\n                            while (out_j < global.cc && visited[x][out_j] == 1) {\n                                visited[x][out_j] = 0\n                                out_j+=1\n                            }\n                            while (out_i < global.rc && visited[out_i][out_j] == 1) {\n                                visited[out_j][out_j] = 0\n                                out_i+=1\n                            }\n                            visited[top_down_walls[j]][i] = 0\n                        }\n                    }\n                    // add all adjacents including diagonals\n                    for (let x = -1; x < 2; x++) {\n                        for (let y = -1; y < 2; y++) {\n                            temp_i = out_i + x\n                            temp_j = out_j + y\n                            if (visited[temp_i][temp_j] == 1 && checked[temp_i][temp_j] == 0 && temp_i != 0 && temp_j != 0 && temp_i != global.rc-1 && temp_j!=global.cc-1) {\n                                q.push([temp_i,temp_j])\n                                checked[temp_i] [temp_j] = 1\n                            } \n                        }\n                    }\n                }\n            }\n        }\n    }\n    return visited\n}\n\nfunction remove_islands(visited) {\n\tlet q = [] // using push and shift\n    let out; \n    let out_i;\n    let out_j;\n    let checked = initialize_visited(global.rc, global.cc)\n    for (let i = 0; i < global.rc; i++) {\n        for (let j = 0; j < global.cc; j++) {\n            if (checked[i][j] == 0 && visited[i][j] == 0) {  \n                q.push([i, j])\n                while (q.length!=0) {\n                    // console.log(visited)\n                    out = q.shift()\n                    out_i = out[0]\n                    out_j = out[1]\n                    if (out_i > 0 && checked[out_i-1][out_j] == 0 && visited[out_i-1][out_j] == 0) {\n                        q.push([out_i-1, out_j])\n                        checked[out_i-1][out_j] = 1\n                    }\n                    if (out_j > 0 && checked[out_i][out_j-1] == 0 && visited[out_i][out_j-1] == 0) {\n                        q.push([out_i, out_j-1])\n                        checked[out_i][out_j-1] = 1\n                    }\n                    if (out_i < global.rc-1 && checked[out_i+1][out_j] == 0 && visited[out_i+1][out_j] == 0) {\n                        q.push([out_i+1, out_j])\n                        checked[out_i+1][out_j] = 1\n                    }\n                    if (out_j < global.cc-1 && checked[out_i][out_j+1] == 0 && visited[out_i][out_j+1] == 0) {\n                        q.push([out_i, out_j+1])\n                        checked[out_i][out_j+1] = 1\n                    }    \n                    // console.log(visited)\n                    // console.log(checked)\n                }\n                // console.log(out_i, out_j)\n                // drill until you hit a 0 or are out of range\n                // need to make sure it is not drilling the borders\n\n                let o;\n                if (out_i+1 < global.rc-2 && visited[out_i+1][out_j] == 1) {\n                    o = drill (out_i+1, out_j, visited, checked)\n                } else if (out_i-1 > 1 && visited[out_i-1][out_j]==1){\n                    o = drill (out_i-1, out_j, visited, checked)\n                } else if (out_j+1 < global.cc-2 && visited[out_i][out_j+1] == 1) {\n                    o = drill (out_i, out_j+1, visited, checked)\n                } else if (out_j-1 > 1 && visited[out_i][out_j-1] == 1) {\n                    o = drill (out_i, out_j-1, visited, checked)\n                }\n                if (o !== undefined) {\n                    visited = o.visited\n                    checked = o.checked\n                }\n                // console.log(o)\n\n                \n            }\n        }\n    }\n    return visited\n\n}\n\nfunction drill(i, j,visited, checked) {\n\n    visited[i][j] = 1\n    while(i < global.rc-1 && visited[i][j] == 1) {\n        // console.log(\"row \", i, j)\n        visited[i][j] = 0\n        checked[i][j] = 0\n        i+=1\n    }\n    visited[i][j] = 1\n    while(j < global.cc-1 && visited[i][j] == 1) {\n        // console.log(\"column \", i,j)\n        visited[i][j] = 0\n        checked[i][j] = 0\n        j+=1\n    }\n    // while(i > 0 && visited[i][j] == 1) {\n    //     console.log(\"row \", i, j)\n    //     visited[i][j] = 0\n    //     i-=1\n    // }\n    // visited[i][j] = 1\n    // while(j < 0 && visited[i][j] == 1) {\n    //     console.log(\"column \", i,j)\n    //     visited[i][j] = 0\n    //     j-=1\n    // }\n    let o = {visited, checked}\n    return o\n}\n\n\n// transform shape of map by changing the values for this\nfunction check_adjacencies(row, col, visited) {\n    let count = 0\n    \n    for (let i = -1; i < 2; i++) {\n        for (let j = -1; j < 2; j++) {\n            try {\n                if (i==-1 && j == -1 || i == 1 && j == -1 || i==1 && j==1 || i==-1&&j==1) {\n                    if (visited[row+i][col+j] == 1) {\n                        count +=2;\n                    }\n                } else if (visited[row + i][col + j] == 1) {\n                    count+=1;\n                }\n                // console.log(count)\n            } catch {\n                count +=1;\n            }\n            if (count >4) {\n                return false\n            }\n        }\n    }\n    return true\n\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n","import React from 'react'\nimport '../../setup/global'\nvar disjointSet = require('disjoint-set')\n\n/*\nCreate a list of all walls, and create a set for each cell, each containing just that one cell.\nFor each wall, in some random order:\nIf the cells divided by this wall belong to distinct sets:\nRemove the current wall.\nJoin the sets of the formerly divided cells.\n*/\n// global.rc = 19\n// global.cc = 19\n// random_kruskal()\nexport default function random_kruskal() {\n    // create setup to check adjacencies\n    let set = disjointSet()\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n    let x, y\n    // randomize array\n    let points = [], maze = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                // need to connect all of the spaces\n                visited[i][j] = {\"i\":i, \"j\":j}\n                set.add(visited[i][j])\n            } else {\n                walls[i][j] = 1\n                points.push([i,j]) // build min spanning tree using these points\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    points = shuffle(points)\n\n    let out_l, out_r\n    // disjoint set is now randomized and they are all walls\n    for (let i = 0; i < points.length; i ++) {\n        x = points[i][0]\n        y = points[i][1]\n        if (walls[x+1][y] == 0 && walls[x-1][y] == 0){\n            out_l = visited[x+1][y]\n            out_r = visited[x-1][y]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x, y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x+1,y], [x,y], [x-1,y])\n            }\n        } else if (walls[x][y+1] == 0 && walls[x][y-1] == 0) {\n            out_l = visited[x][y+1]\n            out_r = visited[x][y-1]\n            if (!set.connected(out_l, out_r)) {\n                // console.log(x,y)\n                walls[x][y] = 0\n                set.union(out_l, out_r)\n                maze.push([x,y+1], [x,y],[x,y-1])\n            }\n        }\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    \n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n\n    // console.log(maze)\n    // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n","import React from 'react'\nimport '../../setup/global'\n\n// global.rc = 19\n// global.cc = 19\n// random_prims()\n/*\nStart with a grid full of walls.\nPick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.\nWhile there are walls in the list:\nPick a random wall from the list. If only one of the two cells that the wall divides is visited, then:\nMake the wall a passage and mark the unvisited cell as part of the maze.\nAdd the neighboring walls of the cell to the wall list.\nRemove the wall from the list.\n*/\nexport default function random_prims() {\n    // create setup to check adjacencies\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n\n    // randomize array\n    let maze = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                walls[i][j] = 0\n            } else {\n                walls[i][j] = 1\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n    // for (let i = 0; i < global.rc; i++) {\n    //     console.log(walls[i].toString())\n    //     // console.log('\\n')\n    // }\n    \n    // picking a random point and marking it as part of the maze\n    // 31 rows, 51 columns; 2n+1 formula so random starts at 29-1 // 14 = 15, 49-1//2 = 24; +1 to avoid edges\n    let in_wall_list = initialize_visited(global.rc, global.cc)\n    let rand_i = 2 * Math.floor(Math.random() * Math.floor( (global.rc-1) /2)) + 1\n    let rand_j = 2 * Math.floor(Math.random() * Math.floor( (global.cc-1) / 2)) + 1\n    console.log(rand_i, \" \", rand_j)\n    // in_wall_list[rand_i][rand_j] = 1\n    visited[rand_i][rand_j]=1\n    let rand_int, out, x, y, ret_val\n    let wall_list = []\n    in_wall_list[rand_i+1][rand_j] = 1\n    in_wall_list[rand_i-1][rand_j] = 1\n    in_wall_list[rand_i][rand_j+1] = 1\n    in_wall_list[rand_i][rand_j-1] = 1\n    wall_list.push([rand_i+1, rand_j], [rand_i-1, rand_j], [rand_i, rand_j+1], [rand_i, rand_j-1])\n    maze.push([rand_i, rand_j])\n    while (wall_list.length > 0) {\n        // console.log(wall_list.length, wall_list)\n        rand_int = Math.floor(Math.random() * Math.floor(wall_list.length))\n        out = wall_list.splice(rand_int,1)[0]\n        x = out[0]\n        y = out[1]\n        console.log(\"rand num \", rand_int, ' x ', x, ' y ', y)\n        if (x == 0 || y == 0 || x == global.rc-1 || y == global.cc -1) {\n            continue\n        }\n        // if one of the two spaces are visited\n        if (visited[x+1][y] == 0 && visited[x-1][y] == 1 || visited[x+1][y] == 1 && visited[x-1][y] == 0){\n            // append walls adjacent to the new cell\n            maze.push([x,y])\n            if (visited[x+1][y] == 0) {\n                ret_val = append_adj(wall_list, x+1,y, in_wall_list, walls)\n                visited[x+1][y] = 1\n                maze.push([x+1,y])\n            } else if (visited[x-1][y] == 0) {\n                ret_val = append_adj(wall_list, x-1,y, in_wall_list, walls)\n                visited[x-1][y] = 1\n                maze.push([x-1,y])\n            }\n            wall_list = ret_val.a \n            in_wall_list = ret_val.in_a\n            walls[x][y] = 0\n            visited[x][y] = 1\n            \n        } else if (visited[x][y+1] == 0 && visited[x][y-1] == 1 || visited[x][y+1] == 1 && visited[x][y-1] == 0) {\n            maze.push([x,y])\n            if (visited[x][y+1] == 0) {\n                ret_val = append_adj(wall_list, x,y+1, in_wall_list, walls)\n                visited[x][y+1] = 1\n                maze.push([x,y+1])\n            } else if (visited[x][y-1] == 0) {\n                ret_val = append_adj(wall_list, x,y-1, in_wall_list, walls)\n                visited[x][y-1] = 1\n                maze.push([x,y-1])\n            }\n            wall_list = ret_val.a \n            in_wall_list= ret_val.in_a\n            walls[x][y] = 0\n            visited[x][y] = 1\n        }\n\n    }\n    \n    for (let i = 0; i < global.rc; i++) {\n        console.log(walls[i].toString())\n        // console.log('\\n')\n    }\n\n\n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n\n    // // console.log(maze)\n    // // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\n\nfunction append_adj(a,row,col, in_a, walls) {\n    console.log(\"before \", a, \" \", row, \" \", col)\n    for (let i = -1; i <=1; i+=2) {\n        if (walls[row+i][col] == 1 && in_a[row+i][col] == 0) {\n            a.push([row+i,col])\n            in_a[row+i][col] = 1\n\n        }\n        if (walls[row][col+i] == 1 && in_a[row][col+i]==0) {\n            a.push([row,col+i])\n            in_a[row][col+i] = 1\n        }\n    }\n    console.log(\"after \", a)\n    \n    return {\"a\": a, \"in_a\":in_a}\n}\n\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n","import React from 'react'\nimport '../../setup/global'\n\n// global.rc = 31\n// global.cc = 51\n// random_prims()\n/*\nChoose any vertex at random and add it to the UST.\nSelect any vertex that is not already in the UST and perform a random walk until you encounter a vertex that is in the UST.\nAdd the vertices and edges touched in the random walk to the UST.\nRepeat 2 and 3 until all vertices have been added to the UST.\n*/\n// wilson()\nexport default function wilson() {\n// function wilson () {\n    let visited = initialize_visited(global.rc, global.cc);\n    let walls = initialize_visited(global.rc, global.cc)\n    let x, y, q, out\n    // randomize array\n    let maze = [], total_vertices = 0, to_visit = []\n    for (let i = 1; i < global.rc-1; i++) {\n        for (let j = 1; j < global.cc-1; j++) {\n            if (j % 2 == 1 && i % 2 == 1) {\n                // need to connect all of the spaces\n                total_vertices ++;\n                to_visit.push([i,j])\n            } else {\n                walls[i][j] = 1\n            }\n        }\n    }\n    for (let i = 0; i < global.cc; i++) {\n        walls[0][i] = 1\n        walls[global.rc-1][i] = 1\n    }\n    for (let i = 0; i < global.rc; i++) {\n        walls[i][0] = 1\n        walls[i][global.cc-1] = 1\n    }\n\n    to_visit = shuffle(to_visit)\n\n    let rand_i = 2 * Math.floor(Math.random() * Math.floor( (global.rc-1) /2)) + 1\n    let rand_j = 2 * Math.floor(Math.random() * Math.floor( (global.cc-1) / 2)) + 1\n    /*\n    algorithm:\n    two dictionaries: current and completed\n    if i, j in current ever sees itself, backtrack\n    backtrack algorithm gets rid of all of the previously seen values and keeps going until it hits an element in \n    the completed set\n    join current and completed and reset current\n    */\n    let current = {}, complete = {}, order = [], res= []\n    let p, s, rand_value, temp, back_ret\n    q = []\n    rand_value = [rand_i, rand_j]\n    s = rand_value.toString()\n    complete[s] = rand_value\n    visited[rand_i][rand_j] = 1\n    // console.log(\"start \", rand_value, complete)\n    for (let i = 0; i < to_visit.length; i++) {\n        if (visited[ to_visit[i][0] ][ to_visit[i][1] ] != 0) {\n            // console.log(\"skip \", to_visit[i])\n            continue\n        } else {\n            // console.log(\"to visit: \", to_visit[i])\n            q.push(to_visit[i])\n            s = to_visit[i].toString()\n            current[s]= to_visit[i]\n            visited[to_visit[i][0]][to_visit[i][1]] = 1\n        }\n        while (q.length != 0) {\n            out = q.shift()\n            x = out[0]\n            y = out[1]\n            s = out.toString()\n            // console.log('out: ', out)\n            // if the popped value is in the complete set, then combine the two sets\n            if (s in complete) {\n                order =get_maze(x,y,visited)\n                // DEBUG\n                // for (let x = 1; x < order.length; x++) {\n                //     if (order[x-1][0] != order[x][0]){\n                //         if (order[x-1][1] != order[x][1]) {\n                //             console.log(\"order is :\", order)\n                //         }\n                //     }\n                // }\n                res = res.concat(order.reverse())\n                complete = {...complete, ...current}\n                // console.log(\"completed at \", s, complete)\n                current = {}\n            // else the popped value is not in the complete set so keep searching\n            } else {\n\n                //TODO: disallow direction reversals\n                rand_value = random_adjacent(x, y, visited)\n                s = rand_value.toString()\n                // console.log(\"not in complete \", s, current, s in current)\n                temp = [x,y]\n                while (s in current) {\n                    // console.log(\"starting backtrack\")\n                    back_ret = backtrack(temp[0], temp[1], rand_value[0], rand_value[1], visited, current)\n                    visited = back_ret.v\n                    current = back_ret.c\n                    temp = rand_value // store this REPEATED value\n                    \n                    // HAVE TO MAKE SURE RAND_VALUE IS NOT IN CURRENT AS WELL\n                    rand_value = random_adjacent(temp[0], temp[1], visited) // get the NEW value\n                    s = rand_value.toString()\n                }\n                // console.log(rand_value[0], visited[temp[0]][temp[1]][0], rand_value[1], visited[temp[0]][temp[1]][1])\n                // if (rand_value[0] == visited[temp[0]][temp[1]][0] && rand_value[1] == visited[temp[0]][temp[1]][1]) {\n                //     console.log('ALERT!!!!!!!')\n                // }\n                visited[rand_value[0]][rand_value[1]] = temp // connect the REPEATED value to the NEW value    \n                current[s] = rand_value\n                q.push(rand_value)\n            }\n        }\n    }\n    maze.push(res[0])\n    let temp1,temp2, temp3\n    for (let i = 1; i < res.length; i++) {\n        // console.log(res[i-1], res[i])\n        temp1 = res[i-1]\n        temp2 = res[i]\n        temp3 = 0\n        // walls[temp1[0]][temp1[1]] = 0\n        // walls[temp2[0]][temp2[1]] = 0\n        // the issue with the random white blip is that there can be cases where two values are on\n        // the same row but not adjacent, i.e. they are far apart\n        \n        if (temp1[0] == temp2[0]) {\n            temp3 = temp1[1] + temp2[1]\n            temp3 /= 2\n            if ( Math.abs(temp3 - temp1[1]) == 1) {\n                maze.push([temp1[0], temp3])\n                walls[temp1[0]][temp3] = 0\n            }\n            // if (Math.abs(temp1[1] - temp2[1]) != 1) {\n            //     console.log(temp1, temp2)\n            // }\n        } else if (temp1[1] == temp2[1]) {\n            temp3 = temp1[0] + temp2[0]\n            temp3 /= 2\n            // if (Math.abs(temp1[0] - temp2[0]) != 1) {\n            //     console.log(temp1, temp2)\n            // }\n            if (Math.abs(temp3 - temp1[0]) == 1) {\n                maze.push([temp3, temp1[1]])\n                walls[temp3][temp1[1]] = 0\n            }\n        }\n        // } else if (Math.abs(temp1[0] - temp2[0]) + Math.abs(temp1[1] - temp2[1]) == 4) {\n        //     maze.push([temp2[0], temp1[1]])\n        //     walls[temp2[0]][temp1[1]] = 0\n        // }\n        // to see if there is any disconnect at all between vertices\n        // if (i < res.length-1 && temp1[0] != temp2[0] && temp1[1] != temp2[1] &&\n        //     temp2[0] != res[i+1][0] && temp2[1] != res[i+1][1]) {\n        //         console.log(temp1, temp2, res[i+1])\n        //     }\n        maze.push(res[i])\n    }\n\n\n    // console.log(set.extract())\n    let ret_walls = []\n    for (let i = 0; i < walls.length; i++) {\n        for (let j = 0; j < walls[0].length; j++) {\n            if (walls[i][j] == 1) {\n                ret_walls.push([i,j])\n            }\n        }\n    }\n    // console.log(ret_walls)\n\n    // // console.log(maze)\n    // // console.log( {\"maze\": maze, \"walls\": ret_walls})\n    return {\"maze\": maze, \"walls\": ret_walls}\n    \n}\n\nfunction get_maze(x, y, visited) {\n    let o = [[x,y]], temp\n    while (visited[x][y] != 1) {\n        temp = visited[x][y]\n        // console.log(x, y, temp)\n        o.push(visited[x][y])\n        x = temp[0]\n        y = temp[1]\n    }\n    return o\n}\n\nfunction backtrack(back_start_i, back_start_j, back_end_i, back_end_j, visited, current) {\n    let out, s\n    while (back_start_i != back_end_i || back_start_j != back_end_j) {\n        out = visited[back_start_i][back_start_j]\n        visited[back_start_i][back_start_j] = 0\n        s = [back_start_i, back_start_j].toString()\n        // console.log(current[s])\n        // console.log(\"backtracking \", back_start_i, back_start_j, back_end_i, back_end_j, out, visited[back_end_i][back_end_j])\n        delete current[s]\n        back_start_i = out[0]\n        back_start_j = out[1]\n    }\n    // console.log(\"backtracking STOP\", out, visited[back_end_i][back_end_j])\n    // console.log(visited[back_start_i][back_start_j])\n    return {v:visited, c:current}\n}\n\nfunction random_adjacent(x, y, visited){\n    let temp, prev, list = []\n    prev = visited[x][y]\n    // 2 directions to travel in \n    if (x == 1 && y == 1 || x==global.rc-2 && y == global.cc-2 || x == 1 && y == global.cc-2 || x== global.rc-2 && y == 1) {\n        if (x == 1 && y == 1) {\n            list = [[x+2,y], [x,y+2]]\n        } else if (x == global.rc-2 && y == global.cc-2){\n            list = [[x-2,y],[x,y-2]]\n        } else if (x == 1 && y==global.cc-2) {\n            list=[[x+2,y],[x,y-2]]\n        } else if (x==global.rc-2 && y ==1) {\n            list = [[x-2,y],[x,y+2]]\n        }\n    } else if (x == 1 || y == 1 || x == global.rc-2 || y == global.cc-2) {\n        // 3 directions to travel in\n        if (x == 1 || x == global.rc-2) {\n            x == 1? list.push([x+2,y]) : list.push([x-2,y])\n            list.push([x,y+2])\n            list.push([x,y-2])\n        } else {\n            y == 1? list.push([x,y+2]) : list.push([x,y-2])\n            list.push([x+2,y])\n            list.push([x-2,y])\n        }\n    } else {\n        // 4 directions to travel in\n        list = [[x+2,y],[x-2,y],[x,y-2],[x,y+2]]\n    }\n    list = shuffle(list)\n    if (list[0][0] == prev[0] && list[0][1] == prev[1]) {\n        // console.log(list[0], prev, \"SAME\", list[1])\n        // console.log(prev, [x,y], list[1])\n        return list[1]\n    } else {\n        // console.log(prev, [x,y], list[0])\n        return list[0]\n    }\n    /* DEBUG\n    start  [ 9, 29 ] { '9,29': [ 9, 29 ] }\n1 [ 15, 23 ]\n[ 15, 23 ] [ 15, 25 ]\n[ 15, 25 ] [ 17, 25 ]\n[ 17, 25 ] [ 17, 27 ]\n[ 17, 27 ] [ 15, 27 ]\n[ 15, 27 ] [ 13, 27 ]\n[ 13, 27 ] [ 13, 29 ]\nbacktracking  13 29 13 27 [ 13, 27 ]\n[ 13, 29 ] [ 13, 27 ]\n[ 13, 27 ] [ 13, 29 ]\n[ 13, 29 ] [ 13, 31 ]\n[ 13, 31 ] [ 11, 31 ]\n[ 11, 31 ] [ 9, 31 ]\n[ 9, 31 ] [ 9, 33 ]\n[ 9, 33 ] [ 9, 35 ]\nbacktracking  9 35 9 33 [ 9, 33 ]\n[ 9, 35 ] [ 9, 33 ]\n[ 9, 33 ] [ 11, 33 ]\nbacktracking  11 33 9 33 [ 9, 33 ]\n[ 11, 33 ] [ 9, 33 ]\n[ 9, 33 ] [ 11, 33 ]\nbacktracking  11 33 11 31 [ 9, 33 ]\nbacktracking  9 33 11 31 [ 11, 33 ]\nbacktracking  11 33 11 31 0\n    */\n\n}\n\n// get random item from object\nfunction random_property (obj) {\n    var keys = Object.keys(obj);\n    return obj[keys[ keys.length * Math.random() << 0]];\n};\n\n\nfunction initialize_visited(row_count, col_count) {\n\tvar visited = new Array(row_count)\n\tfor (let i = 0; i < row_count; i++) {\n\t\tvisited[i] = new Array(col_count).fill(0)\n\t}\n\treturn visited\n}\n\nfunction shuffle(a) {\n    var j, x, i;\n    for (let i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}","module.exports = __webpack_public_path__ + \"static/media/pathfinder-slow1.45a9d4d9.gif\";","import React, { Component } from 'react'\nimport backtrack_bruteforce from './sudoku_algorithms/backtrack_bruteforce'\nimport { Button } from 'react-bootstrap'\nimport './sudoku_global'\nimport backtrack_smart from './sudoku_algorithms/backtrack_smart.js'\nimport {create_puzzle, generate_config} from './sudoku_algorithms/generate_sudoku.js'\n\n/************************* CSS imports *************************/\n// import { Dropdown, DropdownButton } from 'react-bootstrap';\n// import 'bootstrap/dist/css/bootstrap.min.css';\n// import 'jquery/dist/jquery.min.js';\n// import 'bootstrap/dist/js/bootstrap.min.js';\n// import 'bootstrap/dist/css/bootstrap.min.css';\nimport './sudoku_cell.css'\nimport './sudoku_grid.css'\n\n/****************************** Testing gound ******************************/\n\n// this variable is used to clear timeouts \nglobal.vis = 0\nglobal.timeid = []\n\n// global.board = [[0,0,5,3,0,0,0,0,0],\n// [8,0,0,0,0,0,0,2,0],\n// [0,7,0,0,1,0,5,0,0],\n// [4,0,0,0,0,5,3,0,0],\n// [0,1,0,0,7,0,0,0,6],\n// [0,0,3,2,0,0,0,8,0],\n// [0,6,0,5,0,0,0,0,9],\n// [0,0,4,0,0,0,0,3,0],\n// [0,0,0,0,0,9,7,0,0]]\n\n// global.board = [[8,5,0,0,0,2,4,0,0],\n// [7,2,0,0,0,0,0,0,9],\n// [0,0,4,0,0,0,0,0,0],\n// [0,0,0,1,0,7,0,0,2],\n// [3,0,5,0,0,0,9,0,0],\n// [0,4,0,0,0,0,0,0,0],\n// [0,0,0,0,8,0,0,7,0],\n// [0,1,7,0,0,0,0,0,0],\n// [0,0,0,0,3,6,0,4,0]]\n\nglobal.board = generate_config()\ncreate_puzzle(global.board)\n\n/****************************** Class method ******************************/\n\nexport default class Sudoku_grid extends Component {\n\n    constructor(props) {\n        super()\n        this.state = {\n            board: global.board.map(inner => inner.slice()),\n            original: global.board.map(inner => inner.slice()),\n            backtrack_count: 0\n        }\n        this.solve_puzzle = this.solve_puzzle.bind(this)\n        this.visualize_puzzle = this.visualize_puzzle.bind(this)\n        this.resetboard = this.resetboard.bind(this)\n        this.receiveinput = this.receiveinput.bind(this)\n        this.customboard = this.customboard.bind(this)\n    }\n\n/****************************** Solving the sudoku configuration ******************************/\n    visualize_puzzle(type) {\n        let grid = this.state.board.map(inner=>inner.slice())\n        let str\n        global.values = [] // resetting the global variable\n        global.backtrack_count = 0\n        switch(type) {\n            case \"bruteforce\":\n                backtrack_bruteforce(grid, 1) // means I need to store the values for visualization\n                break\n            case \"smart\":\n                backtrack_smart(grid, 1)\n                break        \n        }\n        var ret\n        // console.log(this.state.board)\n        for (let i = 0; i < global.values.length; i++) {\n            // console.log(str, document.getElementById(str).innerHTML)\n            // console.log(document.getElementById(str).innerHTML)\n            global.vis = setTimeout(()=>{\n                this.setState(before => {\n                    let grid = before.board\n                    let counter = before.backtrack_count\n                    if (global.values[i][2] == 0) {\n                        grid[global.values[i][0]][global.values[i][1]] = ''\n                    } else {\n                        grid[global.values[i][0]][global.values[i][1]] = global.values[i][2]\n                    }\n                    if (global.values[i].length > 3) {\n                        // increment backtrack counter\n                        counter ++\n                    }\n                    return {\n                       board: grid,\n                       backtrack_count: counter\n                    }})\n                }, 10*i)\n            global.timeid.push(global.vis)\n            // Errors with this method: (1) results show up before they should\n            //     grid = this.state.board\n            //     if (global.values[i][2] == 0) {\n            //         grid[global.values[i][0]][global.values[i][1]] = ''\n            //     } else {\n            //         grid[global.values[i][0]][global.values[i][1]] = global.values[i][2]\n            //     }\n            //     this.setState({\n            //         board:grid\n            //     })\n            // }, 10 * i)\n\n            // Errors with this method: (1) Difficult to / cannot reset the board\n            //     str = 'sudoku-' + global.values[i][0] + '-' + global.values[i][1]\n            //     if (global.values[i][2] == 0) {\n            //         document.getElementById(str).innerHTML = ' '\n            //     } else {\n            //         document.getElementById(str).innerHTML = global.values[i][2]\n            //     }\n            // }, 10*i)\n            // console.log(global.vis)\n        }\n        // this.setState({\n        //     board:grid\n        // })\n    }\n    \n    solve_puzzle(type) {\n        let grid = this.state.board\n        global.values = []\n        global.backtrack_count = 0\n        var is_solvable\n        switch(type) {\n            case \"bruteforce\":\n                is_solvable = backtrack_bruteforce(grid, 0)\n                break\n            case \"smart\":\n                is_solvable = backtrack_smart(grid, 0)\n                break        \n        }\n        // console.log(global.backtrack_count)\n        if (is_solvable) {\n            this.setState({\n                board:grid,\n                backtrack_count: global.backtrack_count\n            })\n        } else {\n            this.setState({\n                backtrack_count: \"NOT SOLVABLE\"\n            })\n        }\n    }\n\n/****************************** Board Updates ******************************/\n    resetboard() {\n        let str\n        for (let i = 0; i < global.timeid.length; i++) {\n            // console.log(global.timeid[i])\n            clearTimeout(global.timeid[i]);\n        }\n        // console.log(this.state.board)\n        // console.log(this.state.original)\n        // for (let i = 0; i < this.state.original.length; i++) {\n        //     for (let j = 0; j < this.state.original[0].length; j++) {\n        //         str = 'sudoku-' + i + '-' + j\n        //         if (this.state.original[i][j] == 0) {\n        //             // console.log(document.getElementById(str).innerHTML)\n        //             document.getElementById(str).innerHTML = 0\n        //         } else {\n        //             document.getElementById(str).innerHTML = this.state.original[i][j]\n        //         }\n        //     }\n        // }\n        // console.log(\"done\")\n        let grid = this.state.original.map(inner => inner.slice())\n        console.log(this.state.board)\n        console.log(this.state.original)\n        this.setState({\n            board: grid,\n            backtrack_count: 0\n        })\n        // console.log(this.state.board)\n    }\n\n    // generate a random board configuration\n    generateboard() {\n        let grid = generate_config()\n        create_puzzle(grid)\n        let original_grid = grid.map(i => i.slice())\n        this.setState({\n            board: grid,\n            original: original_grid,\n            backtrack_count:0\n        })\n    }\n\n    // Read input from the user for the board\n    receiveinput(event, x, y){\n        let grid = this.state.board    \n        // console.log(event.target.value)\n        try {\n            let new_number = parseInt(event.target.value)\n            if (new_number >= 1 && new_number <= 9) {\n                grid[x][y] = new_number\n            } else {\n                grid[x][y] = 0\n            }\n        } catch {\n            grid[x][y] = 0\n        }\n        this.setState({\n            board: grid\n        })\n    }\n\n    customboard() {\n        this.setState({\n            board: [...Array(9)].map(i=>Array(9).fill(0)),\n            original: [...Array(9)].map(i=>Array(9).fill(0))\n        })\n    }\n\n\n/****************************** Render method ******************************/\n\n    render() {\n        let solve_type = [\"bruteforce\", \"smart\"]\n        return (\n            <div>\n                <nav class=\"navbar navbar-expand-lg bg-light\">\n                    <div class= \"navbar-collapse\">\n                        <ul class=\"navbar-nav mr-auto nav-fill w-100\">\n                            <li class=\"nav-item dropdown\">\n                                <div class=\"dropdown\">\n                                    <button class=\"dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton\" data-toggle=\"dropdown\">\n                                        Visualize\n                                    </button>\n                                    <div class = \"dropdown-menu dropdown-menu-center\" >\n                                        {solve_type.map((name) => {\n                                            return (\n                                                <a class=\"dropdown-item\" onClick = {()=>this.visualize_puzzle(name)}>\n                                                    {name}\n                                                </a>\n                                            )\n                                        })}\n                                    </div>\n                                </div>\n                            </li>\n                            <li class=\"nav-item active\">\n                                <div>\n                                    <button type=\"button\" onClick={()=>this.resetboard()}>\n                                        Reset Board\n                                    </button>\n                                </div>\n                            </li>\n                            <li class=\"nav-item active\">\n                                <div>\n                                    <button type=\"button\" onClick={()=>this.customboard()}>\n                                        Custom Board\n                                    </button>\n                                </div>\n                            </li>\n                            <li>\n                                <div>\n                                    <button type=\"button\" onClick={()=>this.generateboard()}>\n                                        Generate Board\n                                    </button>\n                                </div>\n                            </li>\n                            <li class=\"nav-item dropdown\">\n                                <div class=\"dropdown\" className=\"button-div\">\n                                    <button class=\"dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton\" data-toggle=\"dropdown\">\n                                        Instant\n                                    </button>\n                                    <div class = \"dropdown-menu dropdown-menu-center\" >\n                                        {solve_type.map((name) => {\n                                            return (\n                                                <div>\n                                                    <a class=\"dropdown-item\" onClick = {()=>this.solve_puzzle(name)}>\n                                                        {name}\n                                                    </a>\n                                                </div>\n                                            )\n                                        })}\n                                    </div>\n                                </div>\n                            </li>\n                        </ul>\n                    </div>\n                </nav>\n                \n                <div className=\"sudoku-grid\">\n                    <table>\n                        {/* {console.log(this.state.board)} */}\n                        {this.state.board.map((row, idx) => {\n                            return(\n                                <tr>\n                                    {row.map((unit, idy) => {\n                                        // console.log(\"unit is \", unit)\n                                        {if (unit == 0) {\n                                            // console.log(unit, idy)\n                                            return (\n                                            <td id = {'sudoku-'+idx+'-'+idy}>\n                                                {/* {console.log('sudoku-'+idx+'-'+idy)} */}\n                                                <input value=\"\" onChange={(event)=>this.receiveinput(event, idx, idy)}>\n                                                </input>\n                                            </td>\n                                            )\n                                        } else {\n                                            return (\n                                            <td id = {'sudoku-'+idx+'-'+idy}>\n                                                <input value={unit} onChange={(event) => this.receiveinput(event, idx, idy)}>\n                                                    \n                                                </input>\n                                                {/* {unit} */}\n                                            </td>\n                                            )\n                                        }}\n                                    })}\n                                </tr>\n                            )\n                        })}\n                    </table>\n                </div> \n                <div className=\"back-counter\">\n                    Backtrack Counter: {this.state.backtrack_count}\n                </div>\n\n            </div>\n        )\n    }\n}\n","module.exports = __webpack_public_path__ + \"static/media/sudoku-slow.139d31f6.gif\";","function swap (array,i,j) {\n    let temp = array[i]\n    array[i] = array[j]\n    array[j] = temp\n    let ret_val = [ [i, array[i]], [j, array[j]] ]\n    return ret_val\n}\n\nexport default swap ","import React from 'react'\nimport swap from './lib'\n\nfunction bubblesort(array) {\n    let ret_val = []\n    let swap_values\n    for (let i = 0; i < array.length-1; i++) {\n        for (let j = 0; j < array.length-i-1; j++) {\n            if (array[j] > array[j+1]) {\n                swap_values = swap( array, j, j+1)\n                ret_val.push(swap_values)\n            }\n        }\n    }\n    return ret_val\n    \n}\n\nexport default bubblesort\n","import swap from './lib'\nfunction insertionsort(array) {\n    // console.log(array.length)\n    let ret_values = []\n    let swap_value = []\n    for (let i = 1; i < array.length; i++) {\n        let j = i - 1\n        let key = array[i]\n        while (j >= 0 && array[j] > key) {\n            swap_value = swap(array, j, j+1)\n            ret_values.push(swap_value)\n            j-=1\n        }\n    }\n    return ret_values\n}\n\nexport default insertionsort","// import swap from './lib'\n// a = [5,6,1,2,3,2]\n// b = mergesort(a)\n// console.log(b)\n// console.log(\"ret values are \", ret_values)\nfunction mergesort(array) {\n    let mid, right\n    let ret_values = []\n    for (let current = 1; current < array.length; current *=2) {\n        for (let left=0; left < array.length -1; left+= 2 * current) {\n            mid = Math.min(left + current - 1, array.length - 1)\n            right = Math.min(left + 2 * current - 1, array.length - 1)\n            merge(array, left, mid, right, ret_values)\n            // console.log(array)\n        }\n    }\n    return ret_values\n}\n\n\nfunction merge(array, l, m, r, ret_values) {\n\n    let n1 = m - l + 1;\n    let n2 =  r - m;\n\n    let left_array = array.slice(l, m+1)\n    let right_array = array.slice(m+1, 1+r)\n    let ret_seg = []\n    // console.log(array, left_array, right_array, l, m, n1, n2)\n\n    let i=0, j=0, k=l\n    while(i < n1 && j < n2) {\n        if (left_array[i] <= right_array[j]) {\n            // console.log(array[k], left_array[i])\n            if (array[k] != left_array[i]) {\n                array[k] = left_array[i]\n                ret_seg.push([k, left_array[i]])\n            }\n            i++\n        } else {\n            // console.log(array[k], right_array[j])\n            if (array[k] != right_array[j]) {\n                array[k] = right_array[j]\n                ret_seg.push([k, right_array[j]])\n            }\n            j++\n        }\n        k++\n    }\n    \n    while (i < n1) {\n        if (array[k] != left_array[i]) {\n            array[k] = left_array[i]\n            ret_seg.push([k, left_array[i]])\n        }\n        i++\n        k++\n    }\n\n    while (j < n2) {\n        if (array[k] != right_array[j]) {\n            array[k] = right_array[j]\n            ret_seg.push([k, right_array[j]])\n        }\n        j++\n        k++\n    }\n    ret_values.push(ret_seg)\n}\n\nexport default mergesort","import React, { Component } from 'react'\nimport './sorting_grid.css'\nimport bubblesort from './sorting_algorithms/bubblesort'\nimport insertionsort from './sorting_algorithms/insertionsort'\nimport mergesort from './sorting_algorithms/mergesort'\n\nconst MAX_HEIGHT = window.innerHeight // 644 \n// const MAX_HEIGHT = 100\n// 500 is ok for zoom = 100% on a normal window\nconst MAX_WIDTH = window.innerWidth\n// const MAX_WIDTH = 500 // window.innerWidth = 1280 \nconst ARRAY_SIZE = 20\n// 200 is padding on left and right side\nconst BAR_WIDTH = (MAX_WIDTH - 200) / ARRAY_SIZE\n\n\nexport default class Sorting_grid extends Component {\n    constructor() {\n        super()\n        this.state = {\n            array: Array.from(Array(ARRAY_SIZE), () => Math.floor(Math.random() * ARRAY_SIZE)+1)\n        }\n        this.sort = this.sort.bind(this)\n        this.newArray = this.newArray.bind(this)\n    }\n\n/*********************************** Animation Methods ******************************/\nsort(algorithm) {\n    // document.getElementById('array-0').style.height = `100px`\n    let ret_values\n    switch (algorithm) {\n        case 'bubblesort':\n            ret_values = bubblesort(this.state.array)\n            break\n        case 'insertionsort':\n            ret_values = insertionsort(this.state.array)\n            break\n        case 'mergesort':\n            ret_values = mergesort(this.state.array)\n            break\n    }\n\n    // mergesort is not an in place algorithm so it has its own visualization\n    if (algorithm == 'mergesort') {\n        for (let i = 0; i < ret_values.length; i++) {\n            let j = 0\n            // console.log(ret_values[i])\n            while (j < ret_values[i].length) {\n                let out = ret_values[i][j]\n                let index = out[0]\n                let value = out[1]\n                let s = \"array-\" + index\n                setTimeout(() => {\n                    document.getElementById(s).style.height = `${Math.floor(MAX_HEIGHT * (value/(ARRAY_SIZE+1)))}px`\n                }, i * 1000/ARRAY_SIZE)\n                j++\n            }\n        }\n    } else {\n        // let out, value_i, value_j, index_i, index_j, s_i, s_j\n        // NOTE: have to use let in the loop instead of defining above because:\n        // https://medium.com/@axionoso/watch-out-when-using-settimeout-in-for-loop-js-75a047e27a5f\n        for (let i = 0; i < ret_values.length; i++) {\n            // change height of the element\n            let out = ret_values[i]\n            \n            // ith element being swapped\n            let index_i = out[0][0]\n            let value_i = out[0][1]\n            let s_i = \"array-\" + index_i\n\n            // jth element being swapped\n            let index_j = out[1][0]\n            let value_j = out[1][1]\n            let s_j = \"array-\" + index_j\n            setTimeout(() => {\n                // console.log(i, s_i, s_j, Math.floor(MAX_HEIGHT * (value_i/(ARRAY_SIZE+1))))\n                document.getElementById(s_i).style.height = `${Math.floor(MAX_HEIGHT * (value_i/(ARRAY_SIZE+1)))}px`\n                document.getElementById(s_j).style.height = `${Math.floor(MAX_HEIGHT * (value_j/(ARRAY_SIZE+1)))}px`\n            }, i * 1000 / ARRAY_SIZE)\n        }\n    }\n}\n\nnewArray() {\n    this.setState({\n        array: Array.from(Array(ARRAY_SIZE), () => Math.floor(Math.random() * ARRAY_SIZE +1))\n    })\n}\n\n/*********************************** Render Method ******************************/\n    render() {\n        let algorithms = ['bubblesort', 'insertionsort', 'mergesort']\n        return (\n            <div>\n                <button onClick={this.newArray}>\n                    Create New Array\n                </button>\n                {algorithms.map((algorithm) => {\n                    return (\n                        <button onClick = {()=>this.sort(algorithm)}>\n                            {algorithm}\n                        </button>\n                    )\n                })}\n                <div className=\"sorting-grid\">\n                    {this.state.array.map((value, id) => {\n                        return (\n                            <div\n                                id = {\"array-\" + id}\n                                className=\"bar\" \n                                style={{width: BAR_WIDTH, height: MAX_HEIGHT * (value/(ARRAY_SIZE+1))}}\n                            >\n                                {/* {console.log(\"array-\"+id)} */}\n                            </div>\n                        )\n                    })}\n                </div>\n            </div>\n        )\n    }\n}\n","import React from 'react';\nimport { BrowserRouter, Route, Link, Switch, HashRouter } from \"react-router-dom\";\nimport './App.css'\nimport './images/images.css'\n\n// Pathfinder\nimport Make_grid from './pathfinder/setup/make_grid'\nimport pathfinderGif from './images/pathfinder-slow1.gif'\n\n// Sudoku\nimport Sudoku_grid from './sudoku/sudoku_grid'\nimport sudokuGif from './images/sudoku-slow.gif'\nimport Sorting_grid from './sorting/sorting_grid';\n\nfunction App() {\n\treturn (\n\t\t<div>\n\t\t\t<HashRouter>\n\t\t\t\t<Switch>\n\t\t\t\t\t<Route exact path='/' component={Home}/>\n\t\t\t\t\t<Route exact path='/pathfinder' component = {Pathfinder}/>\n\t\t\t\t\t<Route exact path='/sudoku' component={Sudoku}/>\n\t\t\t\t\t<Route exact path='/sorting' component={Sorting}/>\n\t\t\t\t</Switch>\n\t\t\t</HashRouter>\n\t\t</div>\n\t);\n}\n\nfunction Home() {\n\treturn (\n\t\t<div>\n\t\t\t<div className=\"algorithm\" >\n\t\t\t\t<Link style={{color: \"white\"}} to={'/pathfinder'}>\n\t\t\t\t\t<img class = \"thumbnail\" src={pathfinderGif} alt=\"\" />\n\t\t\t\t\t<h3> Pathfinding Visualizer </h3>\n\t\t\t\t</Link>\n\t\t\t</div>\n\t\t\t<div className=\"algorithm\">\n\t\t\t\t<Link style={{color: \"white\"}} to={'/sudoku'}>\n\t\t\t\t\t<img class = \"thumbnail\" src={sudokuGif} alt=\"\" />\n\t\t\t\t\t<h3> Sudoku Visualizer </h3>\n\t\t\t\t</Link>\n\t\t\t</div>\n\t\t\t<div className=\"algorithm\">\n\t\t\t\t<Link style={{color: \"white\"}} to={'/sorting'}>\n\t\t\t\t\t<h3> Sorting Visualizer </h3>\n\t\t\t\t</Link>\n\t\t\t</div>\n\t\t\t<div className=\"algorithm\">\n\t\t\t\tNQueens will be here\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n  \nfunction Pathfinder() {\n\treturn (\n\t\t<div className = \"app-main\">\n\t\t\t<Make_grid />\n\t\t</div>\n\t)\n}\n\nfunction Sudoku() {\n\treturn (\n\t\t<div className = \"app-sudoku\">\n\t\t\t<Sudoku_grid />\t\n\t\t</div>\n\t)\n}\n\nfunction Sorting() {\n\treturn (\n\t\t<div className = \"app-sorting\">\n\t\t\t<Sorting_grid />\n\t\t</div>\n\t)\n}\n\nfunction NQueens() {\n\treturn (\n\t\t<div className = \"app-queens\">\n\t\t\tNQueens visualizer will be here\n\t\t</div>\n\t)\n\t\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {BrowserRouter as Router} from 'react-router-dom';\nimport App from './App';\n\nReactDOM.render(\n    <Router>\n        <App />\n    </Router>,\n    document.getElementById('root')\n);\n\n"],"sourceRoot":""}